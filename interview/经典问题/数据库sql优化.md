# 联合索引
联合索引是 MySQL 中一种比较常见的索引类型，也叫做复合索引、组合索引或联合唯一索引。它是由两个或多个列组成的索引，可以在多个列上进行查询和排序。

与单个列索引相比，联合索引有以下的优点：

1. 能够提高查询的效率。使用联合索引可以避免 MySQL 对多个单列索引的多次搜索和合并，从而减少磁盘 I/O 操作，提高查询效率。

2. 能够提高排序的效率。排序操作也可以使用联合索引，在多列之间的排序操作中可以大大减少排序阶段的开销。

3. 能够提高覆盖索引的能力。如果联合索引中包含了查询所需要的全部数据，那么就可以避免对基本表的访问，提高查询性能。

需要注意的是，联合索引的顺序对查询效率的影响很大。一个联合索引的所有列都会被纳入索引，每个列的顺序都可以影响查询的效率。如果查询的列顺序与联合索引的顺序不一致，那么就会导致索引无法使用，从而影响查询效率。另外，联合索引的长度也对查询性能有影响。联合索引的长度越短，它在索引表中占用的空间越小，读取时也花费的时间越少，效率也相应地越高。

综上所述，联合索引是一种较为常见的 MySQL 索引类型，在有多个列需要查询或排序时比较适用，但是需要注意顺序和长度的正确设置，以提高查询效率和索引的命中率。

```sql
select ID  from `a`.`b` where ((c = 1) and (d = '2') and (e = 3)) order by f desc limit 0,15 
```
**在最开始的也是没有增加f在联合索引中， 增加了之后已经命中索引**

1.命中索引后CPU仍然很高
压测数据构造有问题，命中索引仍然单表由70%的数据被扫描，理论上一个表业务数据不超过1000，构造数据分散即可。

# 最左前缀索引
等值查询优化-最左前缀索引
最左前缀索引是指创建一个联合索引，根据查询语句用到的列从左到右的顺序，依次匹配索引的前缀列。也就是说，在一个联合索引中，只要查询中使用的列为索引前缀列的最左一列，该联合索引就可以被用来加速查询。

最左前缀索引的优点如下：

1. 可以覆盖多种查询。在最左前缀索引中，只要查询中使用的列为索引前缀列的最左一列，该联合索引就可以被用来加速查询。因此，它可以覆盖多种常见的查询，如 SELECT、WHERE 和 ORDER BY 等。

2. 对于多列联合查询时，只需要建立一个联合索引，就可以减小每个查询所需要的索引数量。

3. 能够提高查询效率。使用最左前缀索引，MySQL 在查询时可以优先基于索引树进行筛选和排序操作，从而大大减少数据系统的 I/O 操作，提高查询效率。

例如，如果我们要查询一个基本表 `employees`，按照以下的顺序在 `id`、`last_name` 和 `first_name` 列上创建最左前缀索引，也就是 id 跟着 last_name 跟着 first_name：

```sql
CREATE INDEX idx_employee ON employees (id, last_name, first_name);
```

则下面的查询语句将使用这个索引：

```sql
SELECT id, last_name, first_name FROM employees WHERE id = 100;
```

而下面的查询语句则不会使用这个索引：

```sql
SELECT id, last_name, first_name FROM employees WHERE last_name = 'Smith';
```

需要注意的是，使用最左前缀索引建议按照查询的数据访问模式来选择维度，常用的查询维度放在靠近前面的位置，以提高搜索的效率。同时，建立联合索引的条件诸如表大小、查询频率和字段类型等都需要考虑到，否则不但会降低查询效率，还会影响数据库的存储与删除效率。

综上所述，通过最左前缀索引的使用，可以大大提高 MySQL 数据库的查询性能，同时也需要根据使用情况和维度等因素来进行优化和调整。

SELECT a WHERE ((s= '12123') AND (x = '22312323')  LIMIT 0,15
s和x为等值查询，筛选性很高，按照最左端建立索引效率会很高。

# 相关问题 无索引
 select a from b where ((c = ?) and (name = ?)
 没有索引，导致全表扫描，同时按照tdsql 的标准 该sql 饼没有order by 语句存在全字段排序的风险.

# 范围查询无法命中索引
在 MySQL 中，范围查询通常指使用比较运算符（如 >、<、>= 或 <=）或范围运算符（如 BETWEEN...AND 或 IN）进行查询的操作。对于这样的查询，如果查询的值域范围较大，那么 MySQL 就不能对整个索引进行扫描，而会转而选择一种称为全表扫描的方法来获取数据。所以可以认为，索引只能对那些用等号（=）进行比较的操作起到优化作用，而不能用于范围查询。

当一个查询涉及到一个范围查询时，该索引的最左的前缀可以被用来产生一个结果集，而剩下的列将会不会被优化索引使用。在使用范围查询时，除非索引的所有列都在查询中用到，否则 MySQL 不能利用索引进行查询优化，这是因为，使用范围查询操作会导致 MySQL 扫描整个索引，并根据相应的行数据进行过滤，而这个过程需要大量的 I/O 操作，因此效率比较低下。

总之，索引能够加速数据库的查询，但是范围查询后面的谓词是用不到索引的，因此在设计数据库索引时，需要考虑到查询的性质，提高设计的规范性和一致性，从而提高查询性能。对于那些需要进行范围查询的操作，优化器没有选择使用索引，这时可以考虑调整SQL语句以减少范围查询或者优化索引以尽可能支持范围查询。

```
where ((CREATED_TIME >= '2001-01-21 16:01:00') and (CREATED_TIME <= '2002-01-11 15:00:00') and (LAST_MODIFIED_TIME <= '2092-03-11 11:22:33') order by LAST_MODIFIED_TIME desc limit 0,100
```
 LAST_MODIFIED_TIME 索引 ，由于  LAST_MODIFIED_TIME 和 CREATED_TIME 都是范围查询，范围查询后面的谓词是用不到索引的，所以索引中只能存在一个，由于 order by 的字段是  LAST_MODIFIED_TIME  考虑 创建如上索引，检测查询的效率也很高。


任务型SQL总体原则

1. 查询走从库
2. 批量操作可自定义size
3. 框架层的定时任务要错开执行时间
3. 搜索相关问题

es备份分片数调整

增加备份分片数为3(调整前为1)，提升搜索性能。


