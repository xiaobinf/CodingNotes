# Cookie Session Token的区别
Cookie、Session 和 Token 都是 Web 应用中用于追踪和管理用户身份的技术。虽然它们之间有相关性，但它们在实现方式和目的方面存在区别。

#### Cookie：

1. Cookie 是存储在客户端（浏览器）的一小段文本信息，通常包括用户凭据、设置和其他应用特定数据。
2. 当用户访问 Web 应用时，服务器会生成一个 Cookie 并通过响应头（`Set-Cookie`）发送给客户端。随后，客户端在每次发起请求时都会带上这个 Cookie。
3. Cookie 有助于识别和区分用户，同时保存用户的偏好设置、登录状态等信息。但 Cookie 的安全性相对较低，容易受到 CSRF 攻击和其他安全风险。

#### Session：

1. Session 是存储在服务器端的一种用户状态管理机制。与 Cookie 不同的是，Session 的信息不会直接暴露给客户端。
2. 当用户访问 Web 应用时，服务器会为用户创建一个唯一的 Session，并生成一个 Session ID。这个 Session ID 可以存储在客户端的 Cookie 中，或以其他方式（如 URL 参数）传递给客户端。
3. Session 的安全性相对较高，但服务器端需要消耗额外的存储资源来维护 Session。此外，因为 Session 保存在服务器端，所以在分布式环境下可能需要考虑 Session 共享和同步问题。

#### Token：

1. Token 是一种基于令牌的用户身份验证和授权机制。Token 包含了有关用户身份的加密信息。
2. 用户首次登录时，服务器会颁发一个 Token，客户端随后会在每次请求时附带这个 Token，以证明自己的身份。
3. Token 通常用于无状态、可扩展和安全性较高的场景，例如 RESTful API 和 OAuth 身份验证。Token 可以包含过期时间，提高了安全性。

总结：Cookie 是存储在客户端的一种状态管理技术，用于跟踪和识别用户。Session 则是服务器端的状态管理机制，依赖客户端的 Cookie 或其他方式来传递 Session ID。Token 是用于身份验证和授权，通常用于无状态、可扩展和强安全性要求的场景。在设计 Web 应用时，可以根据不同的需求和场景选择合适的技术进行实现。

# TCP的拥塞控制有哪四种方法？ TCP保证可靠传输的手段
TCP 是一种面向连接且可靠的协议，它可以提供稳定和可靠的数据传输。下面是关于 TCP 拥塞控制的四种方法：

1. **慢启动（Slow Start）**：慢启动算法在 TCP 连接建立时，将发送窗口（cwnd）设置为一个较小的值，随后逐渐增大。每当接收到一个 ACK，cwnd 的值增加一个 MSS（最大报文段长度）。这样，每个 RTT 后，cwnd 的值大致呈指数增长。慢启动的目的是实现数据传输速率的平滑增长，避免一开始就导致网络拥塞。

2. **拥塞避免（Congestion Avoidance）**：当 cwnd 达到慢启动阈值（ssthresh）后，拥塞避免算法开始工作。在拥塞避免阶段，每接收到一个 ACK，cwnd 增加 `MSS * (MSS/cwnd)`。这样，每个 RTT 后，cwnd 的值大致呈线性增长。拥塞避免可以防止拥塞进一步发展，维持网络传输速率在一个较稳定的水平。

3. **快速重传（Fast Retransmit）**：当接收端连续收到三个相同序号的 ACK 时，快速重传算法会尝试尽快重发丢失的报文段，而不必等待超时重传计时器触发。快速重传有助于对丢失的报文段进行更快速的恢复，提高数据传输效率。

4. **快速恢复（Fast Recovery）**：快速恢复算法在快速重传之后开始工作。当检测到可能的报文段丢失（例如连续三个重复 ACK），快速恢复算法会减小 cwnd 并降低 ssthresh 值。在恢复过程中，cwnd 将采用拥塞避免算法，逐渐线性增加。若发送端接收到新的 ACK，就将网络恢复到拥塞避免状态。

TCP 保证可靠传输的手段：

1. **序列号和确认机制**：TCP 通过给每个传输的字节（或报文段）分配一个唯一序列号，并在接收端发送 ACK 确认序列号来保证数据的有序传输。
2. **校验和**：TCP 使用校验和来检测在传输过程中的数据报文段是否发生错误。如果收到的报文段校验和不正确，接收端会丢弃这个报文段，并不发送 ACK，从而触发发送端的重传。
3. **超时重传**：TCP 使用超时重传机制来处理在传输过程中报文段的丢失。发送端为每个已发送但尚未得到 ACK 的报文段设置一个超时计时器，如果超时未收到 ACK，发送端会重发这个报文段。
4. **流量控制**：TCP 使用滑动窗口协议来控制发送端与接收端之间的数据传输速率。接收端通过 ACK 向发送端通报当前可接受数据的窗口大小，从而使发送端能够适应接收端的处理能力，避免造成拥塞。

总之，通过拥塞控制和各种可靠传输手段，TCP 能够在不同的网络条件下实现稳定和可靠的数据传输。

# 浏览器输入URL处理的过程
当在浏览器地址栏中输入 URL 并按下回车键时，浏览器会经过以下处理过程：

1. **DNS 解析**：浏览器会对输入的 URL 进行 DNS 解析，将域名转换为对应的 IP 地址。DNS 解析的顺序一般是：浏览器缓存 -> 操作系统缓存 -> 路由器缓存 -> 本地 DNS 服务器 -> 递归查询。

2. **建立 TCP 连接**：浏览器与目标服务器之间建立一个 TCP 连接，通常使用三次握手协议来完成。

3. **发送 HTTP 请求**：浏览器构建一个 HTTP 请求报文，其中包含请求方法（如 GET 或 POST）、请求的资源路径、HTTP 协议版本、头部信息（如 Cookie、User-Agent 等）以及可能的请求数据。然后通过已经建立好的 TCP 连接将请求报文发送给服务器。

4. **接收响应**：服务器处理请求后，会返回一个 HTTP 响应报文。响应报文包括 HTTP 协议版本、状态码（如 200、404 等）、响应头（如 Set-Cookie、Content-Type 等）和响应正文（如 HTML 文档、图片、JSON 数据等）。

5. **关闭 TCP 连接**：完成数据传输后，浏览器或服务器会关闭 TCP 连接。在现代 Web 开发中，通过使用持久连接（如 HTTP/1.1 的 Keep-Alive 或 HTTP/2 的多路复用），浏览器可以在一个 TCP 连接上处理多个请求/响应循环，从而提高性能。

6. **解析并渲染页面**：浏览器接收到响应后，将根据响应内容进行以下操作：
   - 解析 HTML，构建 DOM 树。
   - 解析 CSS，构建 CSSOM。
   - 结合 DOM 树和 CSSOM 构建渲染树（Render Tree）。
   - 回流（layout）：计算渲染树中每个元素的布局信息（大小、位置等）。
   - 重绘（paint）：根据渲染树和布局信息，将元素绘制到屏幕上。
   
7. **加载资源**：在解析 HTML 时，浏览器可能需要请求并加载额外的资源（如 JS、CSS 文件、图片、字体等）。浏览器会在处理 HTML、CSS、JS 等资源时执行可能的操作（如解析 JS、应用 CSS 等）。

通过上述过程，浏览器将最终在界面上呈现出页面地址对应的网页内容。值得注意的是，这个过程可能会受到网络状况、服务器响应时间、浏览器性能等多种因素的影响。

# 对称加密与非对称加密的区别
对称加密和非对称加密都是常用的加密算法，它们的区别在于使用的密钥类型和加密方式。

对称加密又称为共享密钥加密，指加密和解密使用的是相同的密钥。
常见的对称加密算法有：DES、3DES、AES等。

非对称加密又称为公钥加密，指加密和解密使用的是不同的密钥。
常见的非对称加密算法有：RSA、DSA等。

由于对称加密只使用一个密钥，因此加密速度相对较快但是密钥的安全性不够高，易被破解，而非对称加密则使用公钥和私钥两个不同的密钥，安全性较高但加密速度较慢。一般情况下，加密数据使用对称加密算法，而在传输密钥时则使用非对称加密算法，这两种加密算法可以结合使用，以提高安全性和效率。

# 重定向的解释
重定向（Redirect）指的是将一个网络请求从一个 URL 地址转发到另一个 URL 地址的过程。

重定向的作用通常是为了更好的网站优化和用户体验。例如：

1. 处理原 URL 的路径或页面被删除，更换，无效等错误情况，重定向到新的有效地址，防止 404 错误的出现。

2. 实现 URL 别名，将 URL 地址使用的名称进行优化，如将咖啡厅页面的地址从 “https://example.com/article/43.html” 重定向至更易记忆的 “https://example.com/cafe”。

3. 实现网站或页面的更新迁移，在对原有网站或页面进行升级，迁移，更新，或作出重大变化时，通过对重定向操作的实施，防止用户和搜索引擎误认为站点或页面消失或不存在。

4. 实现跨域访问，根据网络协议，浏览器限制性的规范，某些请求有限制直接访问外站点，通过重定向的方式，有效的绕过限制，实现跨站访问。

重定向可以通过服务器响应头中的 HTTP 状态码和 Location 字段实现，如常见的 301、302 重定向就是常用的 HTTP 状态码。

# TCP协议如何提高传输效率
TCP（Transmission Control Protocol）是一种面向连接的、可靠的数据传输协议。为了提高传输效率，TCP 采用了以下方法：

1. 滑动窗口机制：TCP 使用滑动窗口机制控制发送方和接收方之间的数据传输速率和流量控制，通过动态调整发送数据的大小，充分利用带宽资源并避免缓存溢出。

2. 慢启动算法：TCP 接收到请求后，初始使用较小的窗口大小进行传输，随着传输的数据量增加，逐步增大窗口大小，避免网络拥塞、数据丢失和突然增大丢包率（packet loss）带来的影响，以此提高传输效率。

3. 拥塞避免算法：TCP 通过调整拥塞窗口大小，避免网络拥塞和丢包率的出现，以此提高传输效率。当拥塞窗口达到一定程度时，TCP 采用拥塞避免算法，动态调整拥塞窗口大小，以此避免数据包丢失。

4. 快速重传和快速恢复：TCP 采用快速重传和快速恢复机制，当传输过程中出现数据丢失的情况时，发送方需要尽快重传缺失的数据，并恢复已经被接收方确认的数据。

5. Nagle 算法：TCP 使用 Nagle 算法控制数据传输，延迟发送较小的数据包，避免网络拥塞和资源浪费。

6. 时间戳：TCP 使用时间戳机制对传输时间进行统计，统计 RTT（Round-trip Time），及时了解数据的传输情况，及时调整窗口大小，以此提高传输效率。

综上所述，TCP 通过多种方式运用滑动窗口机制、拥塞避免算法、快速恢复、快速重传等机制，实现了对网络连接的优化和流量控制，避免了拥塞和丢包现象，从而成功提高了传输效率。

# 正向代理和反向代理
正向代理和反向代理都是常见的计算机网络中的代理服务器形式。

1. 正向代理：正向代理是代理服务器作为客户端代表用户向服务器发送请求，代理服务器不仅可以改变用户的请求，还可以将请求转发给多个目标服务器。正向代理主要用于访问互联网外的资源，常见的如翻墙代理，防火墙访问等。

2. 反向代理：反向代理是代理服务器作为服务器代表多个目标服务器向客户端提供服务，代理服务器可以将请求转发给多个内部服务器，隐藏了实际服务端的 IP 地址，同时还可以负责请求的负载均衡和安全校验等工作。反向代理主要用于运维和网站优化，常见的如 CDN 加速，反向代理负载均衡，防火墙等。

需要注意的是，正向代理和反向代理的区别在于处理的对象不同。正向代理是为客户端提供服务的，它代替客户端向目标服务器请求服务；反向代理是为服务器提供服务的，它代替目标服务器向客户端提供服务。同时，正向代理和反向代理在实现方式上也有所不同，其具体的实现方式可以根据具体的需求进行选择和部署。

# 路由器和交换机在OSI模型的第几层
路由器和交换机在OSI（开放式系统互连）模型的不同层次中发挥着不同的作用。

路由器工作在OSI模型的第三层，即网络层。它的主要功能是根据目标IP地址选择最佳的路径来转发数据包，使数据包能够从源地址到达目标地址。路由器是互联网关键基础设施之一，它可以连接多个不同网络，使得数据能够在这些网络之间传输。

交换机则工作在OSI模型的第二层，即数据链路层。它的主要功能是根据目标MAC地址来转发数据包，将数据包从一个端口转发到另一个端口，以实现不同设备之间的通讯。交换机处理的是帧（Frame）的转发、过滤和处理等问题，而路由器处理的是数据包（Packet）的转发、过滤和处理等问题。

简而言之，路由器负责的是不同网络之间的数据传输，而交换机负责同一个网络内的设备之间的数据交换。两者在网络构建和管理中都有着重要的作用，因此尤其需要了解它们的功能和特点。

# Socket创建客户端和服务器的步骤
使用 Socket 实现网络通信，一般都需要创建一个客户端和服务器，下面是客户端和服务器创建步骤的概述：

1. 服务器端设置（Python 代码）：

```python
import socket

# 创建 socket 对象
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 获取本地主机名
host = socket.gethostname()

# 设置端口
port = 8888

# 绑定端口
server_socket.bind((host, port))

# 设置最大连接数，超过后排队
server_socket.listen(5)

# 等待连接
while True:
    # 建立客户端连接
    client_socket, addr = server_socket.accept()

    # 发送欢迎消息
    message = '欢迎访问菜鸟教程！' + '\r\n'
    client_socket.send(message.encode('utf-8'))

    # 关闭连接
    client_socket.close()
```

2. 客户端设置（Python 代码）：

```python
import socket

# 创建 socket 对象
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 获取本地主机名
host = socket.gethostname()

# 设置端口号
port = 8888

# 连接服务，指定主机和端口号
client_socket.connect((host, port))

# 接收小于 1024 字节的数据
message = client_socket.recv(1024)

print(message.decode('utf-8'))

# 关闭连接
client_socket.close()
```

上述Python代码分为两块：一块是服务器端的代码，一块是客户端的代码。创建服务器端和客户端的具体步骤如下：

1.导入 Socket 模块
```python
import socket
```

2.创建服务器端的 socket 对象和绑定端口等设置
```python
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8888
server_socket.bind((host, port))
```

3.启动服务器端并等待连接
```python
server_socket.listen(5)
while True:
    client_socket, addr = server_socket.accept()
    # do something with client_socket
```

4.客户端创建 socket 对象并建立连接
```python
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
host = socket.gethostname()
port = 8888
client_socket.connect((host, port))
```

5.客户端向服务器发送数据，并接收数据 
```python
client_socket.send(msg.encode('utf-8'))
msg = client_socket.recv(1024)
```

6.关闭 Socket 连接
```python
client_socket.close()
server_socket.close()
```
