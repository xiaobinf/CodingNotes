# sed
`sed`（stream editor）是一个基于文本流编辑的Unix实用工具。它在处理文本文件时非常强大，可以通过简单的命令对文本执行各种操作，如替换、插入、删除、搜索等。`sed` 的优势在于它可以在命令行或脚本中运行，使文本处理变得自动化。

以下是 `sed` 命令的一般形式：

```
sed [options] 'command' input-file > output-file
```

- `options`：可选的命令行标志，用于调整 `sed` 的行为。
- `'command'`：一个 `sed` 命令，用于告诉 `sed` 如何处理输入文件的文本。
- `input-file`：要处理的输入文件。
- `output-file`：处理后的结果文件。通过使用重定向操作符（`>`）将结果重定向到输出文件中。

### 常见 `sed` 命令示例：

1. **查找并替换文本**：以下命令会在文件 `input.txt` 中找到所有的 “apple”，并将其替换为 “orange”，然后将结果重定向到 `output.txt`。

   ```
   sed 's/apple/orange/g' input.txt > output.txt
   ```

   在这里，`s` 是替换命令，`apple` 是要查找的文本，`orange` 是要替换的文本，`g` 表示全局替换（替换每一行中的所有匹配项）。

2. **删除某行**：以下命令会删除文件 `input.txt` 中的第 3 行，并将结果重定向到 `output.txt`。

   ```
   sed '3d' input.txt > output.txt
   ```

3. **在某行之后插入文本**：以下命令会在文件 `input.txt` 中的第 2 行之后插入一行新文本“New line”，然后将结果重定向到 `output.txt`。

   ```
   sed '2a\New line' input.txt > output.txt
   ```

这些示例只是 `sed` 命令能实现的功能的冰山一角。`sed` 是一个强大的文本处理工具，在实际场景中有广泛的应用。

# xargs
`xargs` 是一个 Unix 和类 Unix 操作系统上常用的命令行实用工具，用于将从标准输入读取到的项目（如文件名、目录名和参数）传递给其他命令。`xargs` 通常与 Shell 管道一起使用，可将一个命令的输出转换为另一个命令的参数，从而简化大量文件和参数的处理。

### 常见用法：

以下是使用 `xargs` 的一些常见场景：

1. **查找并删除具有特定扩展名的文件**：此示例将查找并删除当前目录及其子目录中的所有 `.log` 文件。

   ```
   find . -name "*.log" | xargs rm -f
   ```

   这里，`find` 命令查找所有 `.log` 文件，并将结果传递给 `xargs`。然后，`xargs` 将传递给 `rm` 命令的每个文件名作为参数，执行删除操作。

### 常用选项：

以下是 `xargs` 常用选项：

- `-I {placeholder}`：将占位符替换为每个输入项，并在每个条目上执行命令。例如：

  ```
  ls *.txt | xargs -I {} mv {} backup/
  ```

  在此示例中，`{}` 为占位符，`xargs` 会使用 `*.txt` 文件替换这个占位符，并将每个文件移动到名为 `backup` 的目录中。

- `-n [max-args]`：将输入项组合成组，每组包含最多 `[max-args]` 参数。然后，在每组参数上运行一次命令。

- `-P [max-procs]`：在运行命令时，最多允许 `[max-procs]` 个进程并行运行。这可以在处理大量文件时提高效率。

`xargs` 是一个强大且灵活的命令行实用工具，在许多情况下，它可以与其他 Unix 实用工具组合以简化各种任务。

# awk
`awk` 是一种用于处理文本文件的强大文本分析工具，尤其适用于处理定界数据（如通过空格、制表符或逗号分隔的数据）。`awk` 是一种编程语言，命令格式为 `pattern { action }`，当给定模式匹配一行时，会执行相关动作。它通常用于从文本文件中提取、转换和处理数据等操作。

### 基本用法：

以下是 `awk` 的一般形式：

```
awk [options] 'program' file
```

- `options`：命令行选项，如 `-F` 可用于指定输入字段分隔符。
- `'program'`：包含 `pattern { action }` 的 `awk` 程序。
- `file`：输入文件名。

### 示例：

1. **求和**：`data.txt` 文件中存储了以下数据：

   ```
   10 20
   30 40
   50 60
   ```

   若要计算每行的和，我们可以使用以下 `awk` 命令：

   ```
   awk '{ print $1 + $2 }' data.txt
   ```

   输出结果：

   ```
   30
   70
   110
   ```

2. **过滤**：假设我们想要筛选一个文件 `marks.txt` 中的记录，只输出第二列分数大于等于 80 的行：

   ```
   awk '$2 >= 80' marks.txt
   ```

### 常用内建变量：

`awk` 提供了一些内建变量以帮助我们处理数据：

- `NF`：当前行的字段数量。
- `NR`：当前处理的行号。
- `FS`：输入字段分隔符（默认为空格）。
- `OFS`：输出字段分隔符。

### 动作：

动作部分允许您编写处理数据的逻辑，例如：

- 使用 `print` 输出数据（如 `print $1, $2`）。
- 使用条件和循环编写更复杂的处理逻辑。
- 使用内建函数（如 `length()`、`gsub()`、`split()` 等）处理数据。

`awk` 是一种功能强大的文本处理工具，适用于各种场景，尤其是处理表格格式的数据时。在诸如日志分析、数据提取等任务中，`awk` 命令可以提供快速而强大的解决方案。

# rm删除一个硬盘里的东西删除完了，发现还有大量硬盘占用是怎么回事？
在 Linux 系统中，当您使用 `rm` 命令删除一个文件或目录时，它通常将释放硬盘空间。然而，仍然存在一些情况可能导致您在删除某些文件后发现硬盘占用依然很高：

1. **被打开的文件**：如果一个已删除的文件仍然被某个进程打开，虽然文件已从目录中移除，但空间仍会被占用。正常情况下，该空间会在进程关闭文件或者终止后释放。您可以使用 `lsof` 命令列出系统中仍在使用被删除文件的进程。

2. **隐藏或其他分区文件**：您可能只删除了一个分区的部分内容，但其他分区上还存在一些占据空间的隐藏文件。要检查整个系统的硬盘占用情况，可以使用 `df` 和 `du` 命令。

3. **临时文件**：操作系统和某些应用程序可能会在 `/tmp` 或其他临时路径生成临时文件。这些文件可能占用大量磁盘空间。您可以定期清理该临时目录以释放磁盘空间。

4. **可变文件**：系统日志文件、数据库文件、缓存文件等可能在不断增长。如果存在这些文件，可以查看它们的大小并进行适当处理（如日志轮换或清除缓存文件）。

5. **版本控制**：某些文件系统（例如：Btrfs、ZFS等）支持版本控制功能，删除的文件可能被保留在快照中。如果您在类似的文件系统环境下工作，您需要根据文件系统提供的工具删除关联的快照。

建议您使用诸如 `df`、`du`、`lsof` 等命令检查硬盘的占用情况，并相应地清理文件。根据具体情况和需求，可以采取适当措施来释放磁盘空间。