# 关于内存逃逸 何时会发生内存逃逸
golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。
能引起变量逃逸到堆上的典型情况：
>在方法内把局部变量指针返回

局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
>发送指针或带有指针的值到 channel 中

在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。

>在一个切片上存储指针或带指针的值

一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。 slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。

>在 interface 类型上调用方法

在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。


> 为什么fmt.println()打印会发生变量逃逸？

在Go语言中，通过fmt.Println(a ...interface{})打印的变量，都会发生逃逸。这是因为fmt.Println函数的参数是一个空接口类型，即interface{}，它可以接受任意类型的参数。当我们传递一个变量给fmt.Println函数时，Go语言会将这个变量转换为interface{}类型，并将其作为参数传递给fmt.Println函数。由于interface{}类型是一个动态类型，它需要在堆上分配内存空间，因此变量会发生逃逸。

另外，如果我们在函数内部创建一个切片或者map，并将其作为参数传递给fmt.Println函数，也会发生逃逸。这是因为切片和map类型的数据结构需要在堆上分配内存空间，而不是在栈上分配。

总之，通过fmt.Println(a ...interface{})打印的变量，都会发生逃逸。这是因为fmt.Println函数的参数是一个空接口类型，它需要在堆上分配内存空间。如果我们需要避免逃逸，可以使用其他方式打印变量，例如使用fmt.Printf函数或者自定义打印函数。

> 如何避免变量逃逸？

在Go语言中，变量逃逸是指变量在函数内部分配内存空间，但在函数返回后仍然存在于堆上，而不是被自动回收的栈上。变量逃逸会导致程序的性能下降，因为堆上的内存分配和回收需要更多的时间和资源。为了避免变量逃逸，可以采用以下方法：

使用值传递：将变量作为函数参数传递时，使用值传递而不是指针传递。这样可以避免在函数内部分配内存空间，从而避免变量逃逸。

使用局部变量：在函数内部使用局部变量，而不是全局变量或者动态分配内存的变量。局部变量可以在栈上分配内存空间，从而避免变量逃逸。

使用数组或切片：在函数内部使用数组或切片时，可以使用数组或切片的指针作为函数参数传递。这样可以避免在函数内部分配内存空间，从而避免变量逃逸。

使用编译器优化：Go语言的编译器可以进行一些优化，例如内联函数、函数内联等。这些优化可以减少函数调用的开销，从而避免变量逃逸。

总之，为了避免变量逃逸，可以使用值传递、局部变量、数组或切片、编译器优化等方法。这些方法可以减少内存分配和回收的开销，提高程序的性能。

