# 目录

### 一、开场白

> Q：简单自我介绍一下吧
>
> Q：项目和实习经历？（注意使用STAR法则表述）
>

#### star法则

STAR 法则是一种用于回答面试问题的技巧，它可以帮助您清晰、有条理地回答问题，向面试官展示您的能力和经验。STAR 是 Situation（情境）、Task（任务）、Action（行动）和Result（结果）的缩写。

以下是每个部分的详细说明：

Situation（情境）：首先，您需要描述一个具体的情境或场景，例如您所面临的挑战、问题或机会。这可以帮助面试官了解您所面对的情况，并为您的回答提供背景信息。

Task（任务）：接下来，您需要描述您所面临的具体任务或目标。这可以帮助面试官了解您所需要完成的工作，并为您的回答提供重点。

Action（行动）：然后，您需要描述您所采取的具体行动或步骤，以完成任务或达成目标。这可以帮助面试官了解您的能力和经验，并为您的回答提供具体的细节。

Result（结果）：最后，您需要描述您所取得的具体结果或成果。这可以帮助面试官了解您的成就和贡献，并为您的回答提供结论。

使用 STAR 法则回答问题时，您应该尽可能提供具体、量化的信息，例如具体的数字、时间表、成本节约等。这可以帮助面试官更好地了解您的能力和经验，并为您的回答提供更有说服力的证据。

###  二、软件测试基础

#### 工作内容

> Q：按测试内容划分，测试有哪些种类？

按测试内容划分，测试可以分为以下几种类型：

功能测试：测试软件的功能是否符合需求规格说明书中的要求，包括输入、输出、处理和操作等方面。

性能测试：测试软件在不同负载下的性能表现，包括响应时间、吞吐量、并发性等方面。

安全测试：测试软件的安全性，包括漏洞、攻击、数据泄露等方面。

兼容性测试：测试软件在不同操作系统、浏览器、设备等环境下的兼容性，包括界面、功能、性能等方面。

可靠性测试：测试软件的可靠性和稳定性，包括错误处理、恢复能力、容错性等方面。

可用性测试：测试软件的易用性和用户体验，包括界面设计、操作流程、反应速度等方面。

安装测试：测试软件的安装和卸载过程，包括安装、配置、升级、卸载等方面。

国际化测试：测试软件在不同语言、文化、地区等环境下的适应性，包括界面、文本、日期、货币等方面。

接口测试：测试软件与其他系统或组件之间的接口是否正常，包括数据传输、格式、协议等方面。

非功能性测试：测试软件的非功能性要求，包括可维护性、可扩展性、可重用性、可测试性等方面。

以上是按测试内容划分的一些常见的测试类型，不同类型的测试可以针对不同的测试目标和测试需求进行选择和组合。
 
> Q：软件开发（测试）的流程是怎么样的？

软件开发（测试）的流程通常包括以下几个阶段：

需求分析阶段：在这个阶段，开发团队与客户或用户沟通，收集和分析需求，确定软件的功能和性能要求，编写需求规格说明书。

设计阶段：在这个阶段，开发团队根据需求规格说明书，设计软件的架构、模块、接口和数据结构等，编写设计文档。

编码阶段：在这个阶段，开发团队根据设计文档，编写软件代码，进行单元测试和集成测试，确保代码的正确性和质量。

测试阶段：在这个阶段，测试团队根据测试计划和测试用例，对软件进行各种类型的测试，包括功能测试、性能测试、安全测试、兼容性测试等，发现和修复缺陷。

部署阶段：在这个阶段，开发团队将软件部署到生产环境中，进行系统测试和用户验收测试，确保软件的稳定性和可用性。

维护阶段：在这个阶段，开发团队对软件进行维护和升级，包括修复缺陷、添加新功能、优化性能等，确保软件的持续运行和发展。

以上是软件开发（测试）的一般流程，不同的项目和组织可能会有所不同，但是这些阶段通常都是必不可少的。在每个阶段中，开发团队和测试团队需要密切合作，及时沟通和协调，确保软件的质量和进度。

> Q：你印象最深刻的 bug 是？
>
> Q：谈谈你对 CI/CD 的理解

CI/CD 是一种软件开发和交付的方法论，它的目标是通过自动化和持续集成、持续交付、持续部署等技术手段，实现软件开发和交付的高效、快速和可靠。

具体来说，CI/CD 包括以下几个方面：

持续集成（Continuous Integration，CI）：将开发人员的代码集成到共享代码库中，并自动构建和测试代码，以确保代码的质量和稳定性。

持续交付（Continuous Delivery，CD）：将经过测试和验证的代码自动部署到预生产环境中，以便进行进一步的测试和验收。

持续部署（Continuous Deployment，CD）：将经过测试和验证的代码自动部署到生产环境中，以便实现快速、可靠的软件交付。

CI/CD 的优点包括：

提高软件开发和交付的效率和质量，减少手动操作和人为错误。

加快软件交付的速度和频率，缩短上线时间和反馈周期。

提高软件的可靠性和稳定性，减少故障和风险。

改善开发团队和运维团队之间的协作和沟通，促进团队的合作和创新。

总之，CI/CD 是一种现代化的软件开发和交付方法，它可以帮助开发团队和运维团队更好地协作和交付软件，提高软件的质量和效率，满足用户的需求和期望。

> Q：谈谈你对 DevOps 的理解

DevOps 是一种软件开发和运维的方法论，它的目标是通过自动化和协作，实现软件开发和运维的高效、快速和可靠。

具体来说，DevOps 包括以下几个方面：

自动化：通过自动化工具和流程，实现软件开发、测试、部署和运维的自动化，减少手动操作和人为错误。

协作：通过团队协作和沟通，实现开发团队和运维团队之间的协作和共享，促进团队的合作和创新。

持续交付：通过持续集成、持续交付和持续部署等技术手段，实现软件的快速、可靠的交付和部署。

监控和反馈：通过监控和反馈机制，实时监测软件的运行状态和性能指标，及时发现和解决问题，提高软件的可靠性和稳定性。

DevOps 的优点包括：

提高软件开发和运维的效率和质量，减少手动操作和人为错误。

加快软件交付的速度和频率，缩短上线时间和反馈周期。

提高软件的可靠性和稳定性，减少故障和风险。

改善开发团队和运维团队之间的协作和沟通，促进团队的合作和创新。

总之，DevOps 是一种现代化的软件开发和运维方法，它可以帮助开发团队和运维团队更好地协作和交付软件，提高软件的质量和效率，满足用户的需求和期望。

> Q: CI/CD和DEVOPS的关系
CICD（Continuous Integration/Continuous Delivery）和DevOps是紧密相关的概念，它们之间有着密切的关系。

CICD是一种软件开发和交付的方法论，它强调通过自动化和持续集成、持续交付、持续部署等技术手段，实现软件开发和交付的高效、快速和可靠。CICD的目标是将软件开发和交付的过程自动化，减少手动操作和人为错误，提高软件的质量和效率。

DevOps是一种软件开发和运维的方法论，它强调通过自动化和协作，实现软件开发和运维的高效、快速和可靠。DevOps的目标是将软件开发和运维的过程整合起来，促进开发团队和运维团队之间的协作和共享，提高软件的可靠性和稳定性。

CICD和DevOps的关系在于，CICD是实现DevOps的一种技术手段。CICD强调自动化和持续集成、持续交付、持续部署等技术手段，可以帮助开发团队和运维团队更好地协作和交付软件，实现DevOps的目标。同时，DevOps强调协作和共享，可以促进CICD的实现和应用，提高软件的质量和效率。

因此，CICD和DevOps是相互依存、相互促进的概念，它们的目标都是实现软件开发和交付的高效、快速和可靠。

> Q：什么是 BDD ? 什么是 TDD ?

BDD（Behavior-Driven Development）和TDD（Test-Driven Development）都是软件开发中常用的测试方法。

BDD是一种基于行为的测试方法，它强调测试用例应该从用户的行为和需求出发，以用户故事和场景为基础，编写测试用例和测试代码。BDD的目标是帮助开发团队和业务团队更好地沟通和理解需求，以及更好地测试和验证软件的功能和性能。

TDD是一种基于测试的开发方法，它强调在编写代码之前，先编写测试用例，然后编写代码来满足测试用例的要求。TDD的目标是帮助开发团队更好地理解需求和设计，以及更好地测试和验证代码的正确性和质量。

两者的区别在于，BDD更加强调测试用例的编写应该从用户的行为和需求出发，以用户故事和场景为基础，更加注重测试用例的可读性和可维护性；而TDD更加强调测试用例的编写应该在编写代码之前，以测试驱动开发的方式来设计和实现代码，更加注重测试用例的覆盖率和正确性。

总之，BDD和TDD都是软件开发中常用的测试方法，它们都强调测试在软件开发中的重要性，可以帮助开发团队更好地理解需求和设计，以及更好地测试和验证软件的功能和性能。

> Q：APP的一个页面，你怎么区分是原生Native页面，还是H5？
- 看断网的情况。正常打开就是原生的。 404就是H5
- 安卓手机可以打开开发者选项中的显示布局边界，页面元素很多的情况下布局是一整块的是h5的，布局密密麻麻的是原生控件。页面有布局的是原生的，否则为h5页面。（仅针对安卓手机适用）。
- 复制文章的提示。长按页面试试，如果出现文字选择、粘贴功能的是H5页面，否则是native原生的页面。
- 页面加载方式。新页面导航栏下面有一条加载的线的话，这个页面就是H5页面，如果没有就是原生的。或者出现白屏的话，大概率是的。
- app顶部 导航栏是否会有关闭的操作。如果APP顶部导航栏当中出现了关闭按钮或者有关闭的图标，那么当前的页面肯定的H5，原生的不会出现（除非设计开发者故意弄的）
- 判断页面 下拉刷新。如果界面没有明显刷新现象的是原生的，如果有明显刷新现象（比如闪一下）的是H5页面（ios和android）。
- 下拉页面的时候显示网址提供方的一定是H5。
#### 测试方法

> Q：黑盒测试的方法有哪些？

黑盒测试是一种软件测试方法，它不考虑软件的内部结构和实现细节，只关注软件的输入和输出，以及软件是否符合规格说明书和用户需求。常用的黑盒测试方法包括以下几种：

等价类划分法：将输入数据划分为若干个等价类，每个等价类代表一组具有相同特征的输入数据，然后从每个等价类中选择一个或多个测试用例进行测试。

边界值分析法：将输入数据的边界值作为测试用例，测试软件在边界值处的行为和响应。

决策表测试法：将软件的决策表转换为测试用例，测试软件在不同条件下的行为和响应。

因果图测试法：将软件的因果图转换为测试用例，测试软件在不同条件下的行为和响应。

状态转换测试法：将软件的状态转换图转换为测试用例，测试软件在不同状态下的行为和响应。

错误推测测试法：根据常见的错误和异常情况，推测软件可能出现的错误和异常情况，然后编写测试用例进行测试。

以上是常用的黑盒测试方法，不同的测试方法适用于不同的测试场景和测试目的，测试人员可以根据具体情况选择合适的测试方法进行测试。

> Q：白盒测试的方法有哪些？

白盒测试是一种软件测试方法，它考虑软件的内部结构和实现细节，以代码为基础，通过检查代码的逻辑和执行路径，来测试软件的正确性和质量。常用的白盒测试方法包括以下几种：

语句覆盖测试：测试用例覆盖代码中的每个语句至少一次。

判定覆盖测试：测试用例覆盖代码中的每个判定条件的真假至少一次。

条件覆盖测试：测试用例覆盖代码中的每个条件的真假至少一次。

路径覆盖测试：测试用例覆盖代码中的每个可能的执行路径至少一次。

边界值测试：测试用例覆盖代码中的边界值情况，例如最大值、最小值、空值等。

异常处理测试：测试用例覆盖代码中的异常处理情况，例如输入错误、文件不存在等。

性能测试：测试软件的性能和资源消耗情况，例如响应时间、并发用户数等。

以上是常用的白盒测试方法，不同的测试方法适用于不同的测试场景和测试目的，测试人员可以根据具体情况选择合适的测试方法进行测试。

> Q：什么是单元测试？

单元测试是一种软件测试方法，它是针对软件中最小的可测试单元——函数、方法或类等进行测试的过程。单元测试的目的是验证每个单元的功能是否正确，以及是否符合预期的行为和输出。

单元测试通常由开发人员编写，它可以在开发过程中及时发现和解决代码中的问题，提高代码的质量和可维护性。单元测试可以帮助开发人员更好地理解需求和设计，以及更好地测试和验证代码的正确性和质量。

单元测试的特点包括：

自动化：单元测试通常使用自动化测试工具和框架进行测试，可以快速、准确地执行测试用例，减少手动操作和人为错误。

独立性：单元测试通常是针对单个函数、方法或类进行测试，与其他模块和组件相互独立，可以更好地定位和解决问题。

可重复性：单元测试的测试用例可以重复执行，可以验证代码的正确性和稳定性。

可维护性：单元测试可以帮助开发人员更好地理解代码的结构和实现，以及更好地维护和更新代码。

总之，单元测试是一种重要的软件测试方法，它可以帮助开发人员更好地测试和验证代码的正确性和质量，提高代码的质量和可维护性。

> Q：什么是集成测试？

集成测试是一种软件测试方法，它是在单元测试之后，将多个单元组合在一起进行测试的过程。集成测试的目的是验证不同单元之间的交互和协作是否正确，以及是否符合预期的行为和输出。

集成测试通常由测试人员或测试团队进行，它可以在软件开发的不同阶段进行，例如模块集成测试、系统集成测试、验收测试等。集成测试可以帮助测试人员发现和解决不同单元之间的问题，以及验证软件的整体功能和性能。

集成测试的特点包括：

逐步集成：集成测试通常采用逐步集成的方式，从少量单元开始，逐步增加单元的数量和复杂度，直到整个系统被完全集成。

接口测试：集成测试通常关注不同单元之间的接口和交互，测试单元之间的数据传递、函数调用、消息传递等。

功能测试：集成测试也包括对整个系统的功能进行测试，验证系统是否符合预期的行为和输出。

性能测试：集成测试也可以包括对系统的性能和负载进行测试，例如响应时间、并发用户数等。

总之，集成测试是一种重要的软件测试方法，它可以帮助测试人员发现和解决不同单元之间的问题，以及验证软件的整体功能和性能。集成测试可以在软件开发的不同阶段进行，以确保软件的质量和稳定性。

> Q：测试用例怎么编写与设计？

测试用例是软件测试的基本单元，它描述了一个或多个测试场景，以及预期的行为和输出。测试用例的编写和设计是软件测试的重要环节，下面是一些编写和设计测试用例的基本步骤：

确定测试目标：测试用例的编写和设计应该始于测试目标的明确和清晰。测试目标应该包括测试的范围、测试的目的、测试的重点等。

确定测试场景：测试用例应该基于测试场景进行设计，测试场景应该包括输入、操作、预期输出等。

设计测试用例：根据测试场景，设计测试用例，测试用例应该包括测试步骤、输入数据、预期输出等。

确定测试数据：测试用例的设计需要确定测试数据，测试数据应该包括正常数据、边界数据、异常数据等。

确定测试环境：测试用例的设计需要确定测试环境，测试环境应该包括硬件、软件、网络等。

确定测试方法：测试用例的设计需要确定测试方法，测试方法应该包括手动测试、自动化测试等。

编写测试用例：根据测试场景和测试目标，编写测试用例，测试用例应该清晰、简洁、易于理解和执行。

执行测试用例：执行测试用例，记录测试结果，包括测试通过、测试失败、测试错误等。

分析测试结果：分析测试结果，确定问题的原因和解决方案，以及是否需要重新设计和编写测试用例。

总之，测试用例的编写和设计是软件测试的重要环节，它需要根据测试目标、测试场景、测试数据、测试环境、测试方法等因素进行设计和编写。测试用例应该清晰、简洁、易于理解和执行，以确保测试的有效性和可靠性。

> Q：什么是灰盒测试？

灰盒测试是介于黑盒测试和白盒测试之间的一种测试方法，它既考虑了系统的功能和行为，又考虑了系统的内部结构和实现。灰盒测试通常是在有限的代码访问权限下进行的，例如可以查看代码、调试代码、修改配置文件等。

灰盒测试的特点包括：

既考虑功能又考虑结构：灰盒测试既考虑系统的功能和行为，又考虑系统的内部结构和实现，可以更全面地测试系统的质量和稳定性。

有限的代码访问权限：灰盒测试通常是在有限的代码访问权限下进行的，例如可以查看代码、调试代码、修改配置文件等，可以更好地理解和测试系统的内部结构和实现。

可重复性：灰盒测试的测试用例可以重复执行，可以验证代码的正确性和稳定性。

可维护性：灰盒测试可以帮助测试人员更好地理解代码的结构和实现，以及更好地维护和更新代码。

灰盒测试通常包括以下测试方法：

分支覆盖测试：测试人员通过查看代码，测试每个分支的执行情况，以确保代码的完整性和正确性。

代码审查：测试人员通过查看代码，发现和解决代码中的问题，以确保代码的质量和可维护性。

数据库测试：测试人员通过查看数据库结构和数据，测试系统的数据完整性和正确性。

总之，灰盒测试是一种介于黑盒测试和白盒测试之间的测试方法，它既考虑了系统的功能和行为，又考虑了系统的内部结构和实现。灰盒测试可以更全面地测试系统的质量和稳定性，以确保系统的正确性和可靠性。

#### 测试文档
<details>
<summary>测试用例都包含哪些要素？</summary>
测试用例是用来验证软件系统是否符合需求和规格说明的一组测试步骤和输入数据。测试用例通常包含以下要素：

测试用例编号：用于标识测试用例的唯一编号。

测试用例名称：用于描述测试用例的名称，通常包含被测试的功能或模块名称。

测试用例描述：用于描述测试用例的目的、输入数据、预期结果等信息。

测试步骤：用于描述测试用例的具体步骤，包括输入数据、操作步骤、预期结果等信息。

输入数据：用于描述测试用例的输入数据，包括输入数据的类型、格式、范围等信息。

预期结果：用于描述测试用例的预期结果，包括输出数据的类型、格式、范围等信息。

实际结果：用于记录测试用例的实际结果，包括输出数据的类型、格式、范围等信息。

测试结果：用于记录测试用例的测试结果，包括测试通过、测试失败、测试未完成等信息。

测试人员：用于记录测试用例的测试人员，包括测试人员的姓名、工号等信息。

测试日期：用于记录测试用例的测试日期，包括测试开始时间、测试结束时间等信息。

总之，测试用例是用来验证软件系统是否符合需求和规格说明的一组测试步骤和输入数据，包含测试用例编号、测试用例名称、测试用例描述、测试步骤、输入数据、预期结果、实际结果、测试结果、测试人员和测试日期等要素。
</details>


<details>
<summary>测试报告需要展示哪些要素？</summary>
</details>
>
#### 自动化测试
> Q：定位xpath路径都有哪些方法？

<details>
<summary>Q：如何定位一个动态的元素？</summary>
定位一个动态的元素，可以使用浏览器的开发者工具来进行查找和定位。具体步骤如下：

打开浏览器，进入需要定位元素的网页。

按下F12键或者右键选择“检查”打开浏览器的开发者工具。

在开发者工具中选择“元素”或“检查”选项卡。

使用鼠标在页面上点击需要定位的元素，开发者工具会自动定位到该元素的代码位置。

如果需要定位一个动态的元素，可以使用开发者工具中的“监视”或“网络”选项卡，查看元素的动态变化和网络请求。

如果元素是通过JavaScript代码动态生成的，可以使用开发者工具中的“调试”选项卡，设置断点、单步执行等方式进行调试。

如果元素是通过Ajax请求动态加载的，可以使用开发者工具中的“网络”选项卡，查看Ajax请求的响应内容和状态码。

总之，定位一个动态的元素，可以使用浏览器的开发者工具进行查找和定位，通过监视元素、查看网络请求、调试JavaScript代码等方式进行定位和调试。
</details>

<details>
<summary>Q：如何定位类似于悬浮在web页面上的元素（类似于web上飞来飞去的广告）</summary>
定位类似于悬浮在web页面上的元素，可以使用浏览器的开发者工具来进行查找和定位。具体步骤如下：

打开浏览器，进入需要定位元素的网页。

按下F12键或者右键选择“检查”打开浏览器的开发者工具。

在开发者工具中选择“元素”或“检查”选项卡。

使用鼠标在页面上点击需要定位的元素，开发者工具会自动定位到该元素的代码位置。

如果需要查找类似于悬浮在页面上的元素，可以使用开发者工具中的“选择元素”或“查找元素”功能，通过鼠标选择或输入元素的CSS选择器、XPath表达式等方式进行查找和定位。

如果需要调试类似于悬浮在页面上的元素的JavaScript代码，可以使用开发者工具中的“调试”选项卡，设置断点、单步执行等方式进行调试。

总之，定位类似于悬浮在web页面上的元素，可以使用浏览器的开发者工具进行查找和定位，通过选择元素、查找元素、调试JavaScript代码等方式进行定位和调试。
</details>

> Q：列举你知道的自动化测试工具

#### 测试工具
<details>
<summary>Q：聊聊 fiddler 的抓包原理</summary>
finddler是一个Web代理服务器，它可以捕获客户端和服务器之间的HTTP（S）请求。它的工作原理是：
finddler启动后，会自动将代理服务器设置为本机，端口为8888。
当客户端发起一个HTTP（S）请求时，finddler会拦截该请求，并伪装成客户端发送相同的请求给Web服务器。
Web服务器收到finddler的请求后，会返回响应给finddler。
finddler收到Web服务器的响应后，会保存并分析该响应，并伪装成Web服务器返回相同的响应给客户端。
这样，finddler就可以查看和修改客户端和服务器之间的所有数据包。
如果请求是HTTPS的，finddler还需要进行一些额外的步骤，如生成自签名证书，解密对称密钥等，以便能够解密加密的数据包。
</details>


<details>
<summary>Q：fiddler 怎么抓取 https 请求？</summary>
Fiddler是一款常用的网络抓包工具，它可以抓取HTTP和HTTPS请求并对其进行分析。要抓取HTTPS请求，需要进行以下设置：

安装Fiddler证书：Fiddler需要安装自己的根证书才能解密HTTPS流量。在Fiddler中选择“Tools”->“Options”->“HTTPS”选项卡，勾选“Decrypt HTTPS traffic”选项，并点击“Actions”->“Export Root Certificate to Desktop”按钮，将证书保存到桌面。

安装Fiddler证书到浏览器：将Fiddler证书导入到浏览器的受信任根证书中。在浏览器中打开证书文件，选择“安装证书”，选择“计算机账户”和“受信任的根证书颁发机构”，完成证书安装。

启用HTTPS代理：在Fiddler中选择“Tools”->“Options”->“Connections”选项卡，勾选“Allow remote computers to connect”和“Act as system proxy on startup”选项。

启用HTTPS解密：在Fiddler中选择“Tools”->“Options”->“HTTPS”选项卡，勾选“Decrypt HTTPS traffic”选项。

开始抓取HTTPS请求：在Fiddler中选择“File”->“Capture Traffic”选项，开始抓取HTTPS请求。

总之，要抓取HTTPS请求，需要安装Fiddler证书、安装证书到浏览器、启用HTTPS代理和启用HTTPS解密等步骤。这样就可以使用Fiddler抓取HTTPS请求并进行分析。
</details> 


<details>
<summary>Q：wireshark 抓包的头部有什么？</summary>
Wireshark是一款常用的网络抓包工具，它可以抓取网络数据包并对其进行分析。Wireshark抓包的头部包含以下信息：

Frame：帧头，包含帧的长度、时间戳、帧的序号等信息。

Ethernet：以太网头，包含源MAC地址、目的MAC地址、协议类型等信息。

IP：IP头，包含源IP地址、目的IP地址、协议类型、TTL等信息。

TCP/UDP：TCP或UDP头，包含源端口号、目的端口号、序号、确认号、标志位等信息。

HTTP/HTTPS：HTTP或HTTPS头，包含请求方法、请求URL、响应状态码、响应内容等信息。

DNS：DNS头，包含查询类型、查询名称、响应IP地址等信息。

SSL/TLS：SSL或TLS头，包含加密算法、证书信息等信息。

ICMP：ICMP头，包含类型、代码、校验和等信息。

总之，Wireshark抓包的头部包含了网络数据包的各种信息，包括帧头、以太网头、IP头、TCP/UDP头、HTTP/HTTPS头、DNS头、SSL/TLS头、ICMP头等。这些信息可以帮助用户了解网络数据包的来源、目的、协议类型、内容等信息，从而进行网络分析和故障排除。
</details>


### 三、软件测试实战

#### 排查问题的思路

> Q：网页崩溃的原因是什么？
网页崩溃（Crash）通常是指Web浏览器中的JavaScript脚本执行错误、浏览器窗口异常关闭或操作系统崩溃等问题导致的页面无法正常显示或无法关闭。从测试角度分析网页崩溃的原因，主要有以下几个方面：

1. JavaScript代码错误：由于JavaScript脚本是浏览器中的主要执行代码，因此如果脚本中存在语法错误、变量调用错误等问题，就会导致页面出现崩溃情况，需要对JavaScript代码进行严格的测试和debug。

2. 跨域问题：由于浏览器安全策略的限制，如果网站A的JavaScript代码试图访问来自另一个域名的资源（如CSS文件、JavaScript文件、图片等），就可能会出现跨域问题导致页面崩溃，因此需要进行跨域安全性测试，避免这种问题的发生。

3. 插件失效：插件的失效可能导致浏览器出现问题，从而导致网页崩溃，需要确认插件是否与当前浏览器版本兼容并进行相关的插件测试及版本兼容测试。

4. 网络问题：网络连接不稳定、带宽不足、DNS解析错误等网络问题也可能导致页面崩溃，需要进行网络性能测试和网络稳定性测试，排除这类问题的影响。

总之，对于网页崩溃这种问题，测试人员需要从多个方面进行分析和测试，从JavaScript代码本身、跨域安全性、插件和网络等多个方面排查问题，以保证网页的稳定性和用户体验。同时，还需要适当的监控和记录网页崩溃情况，及时进行分析和排查。

> Q：app闪退的原因？
在移动应用开发中，app发生闪退（Crash）是比较常见的问题，通常包括系统原因、代码缺陷、内存问题、网络及数据异常、设备兼容性等。从系统测试角度分析，可以分以下几个方面：

1. 代码质量问题：代码缺陷是导致app闪退的主要原因之一。测试人员需要对应用程序代码进行全面测试和Debug，识别代码中的漏洞、Bug或者逻辑问题，及时修复问题，提高代码质量。

2. 内存问题：应用程序的运行过程中，如果产生大量的内存泄露或者内存泄漏就容易造成闪退，测试人员需要尽可能模拟真实用户的使用场景或者极限数据情况，以验证应用程序的内存管理能力。

3. 设备兼容性：在不同的设备上运行同一应用可能出现兼容性问题，如某些功能无法使用、闪退等，测试人员需要进行设备兼容性测试，确保应用在不同类型的设备上都能正常运行。

4. 网络及数据异常：网络或者数据异常也会导致应用闪退。例如：网络请求超时、资源请求失败等。测试人员应当针对网络问题进行测试，确认应用程序在网络异常时能够做出恰当的响应，如取消操作、提示网络异常等。

5. 第三方库或组件问题：很多应用都使用第三方组件或者库，如果第三方库或组件的质量不佳或与应用不兼容会引起应用的崩溃。测试人员需要测试应用程序所依赖的第三方库或组件，确认其稳定性和功能完整性。

总之，在系统测试中，通过全面的测试策略，覆盖关键业务场景、大量数据、三方库、多样化设备等，来发现并及时修复各种可能导致应用崩溃的问题，确保应用的稳定性和可靠性。
> Q：偶然闪退的排查？
分析app偶然闪退问题，从系统测试的角度出发，可以采用以下方法和思路进行梳理：

1. 收集并记录问题信息：首先需要记录闪退时出现的错误信息、日志等关键信息，包括应用程序版本、安卓系统版本等，这些信息有助于问题的复现和定位，便于后续排查和处理问题。

2. 排查用户使用情况：根据用户使用app的情况、机型、操作步骤等情况，对常见的操作和场景进行模拟测试，并尽可能重现问题，以确认问题的性质和严重程度。

3. 详细测试关键模块：针对app的主要功能模块和关键页面进行测试，包括界面、交互、存储、网络、权限、通知等方面的测试，以确认关键模块是否存在问题。

4. 进行压力测试：通过模拟高并发场景和大量数据、流量的测试，确认是否存在内存、CPU等性能问题，并结合测试结果对瓶颈进行处理。

5. 稳定性测试：对app进行长时运行测试，验证app是否存在内存泄露、资源耗尽等问题，以确保app的稳定性。

6. 安全性测试：确保app不会因为安全漏洞而出现闪退、崩溃等情况，包括安全性、隐私性、系统权限等多个方面的测试。

7. 版本兼容性测试：对不同型号的设备和不同版本的操作系统进行兼容性测试，以确保app在多种平台上都能够正常工作。

总之，对于app偶然闪退的问题，需要在对闪退情况进行精准记录的基础上，从多个方面入手，如用户使用情况、关键模块测试、压力测试、稳定性测试、安全性测试、版本兼容性测试等方面进行全面测试，才能更全面的排查闪退问题并进行处理，以提高app的稳定性和用户体验。

> Q：网页卡顿通常是指打开或使用网页时，出现网页反应迟缓、滑动不畅等现象，从系统测试的角度出发，网页卡顿的原因可能包括以下几个方面：

1. 网络性能问题：当页面需要大量请求数据或网络带宽不足时，就容易出现网页卡顿的现象，需要进行网络性能测试、性能调优等方面的测试。

2. 前端代码问题：当网页前端代码存在问题，例如大量的JavaScript代码、错误的CSS样式、页面过大等原因，就会导致页面加载缓慢、交互迟缓等现象，需要进行代码规范性、线程安全等方面的测试。

3. 浏览器问题：不同的浏览器兼容性不同，可能导致页面卡顿或崩溃，需要进行浏览器兼容性测试和性能测试，以确认浏览器是否存在性能问题、卡顿等现象。

4. 压力问题：如果网站流量过大，服务器的并发处理能力不足，就会导致网页响应缓慢或卡顿现象，需要进行服务器性能测试、容量规划等方面的测试。

5. 数据库问题：如果数据库性能不足，就会导致数据处理缓慢，从而影响网页的正常访问，需要进行数据库性能测试和调优。

综上所述，针对网页卡顿的问题，从系统测试角度出发，需要综合考虑多个因素，包括网络性能、前端代码、浏览器、压力、数据库等多个方面，通过性能测试、负载测试、压力测试、兼容性测试、数据库测试等方面的测试，找出问题的根源，并进行相关的优化和改进，提高网页的稳定性和用户体验。
> Q：10%的用户反馈用不了功能，你讲如何排查？
对于10%的用户反馈用不了功能，从系统测试的角度出发，可能需要采用以下步骤和思路进行排查：

1. 确认反馈情况：首先需要收集用户反馈的信息，包括用不了的功能具体是哪些、操作步骤、系统版本、设备型号等信息，以便对问题进行定位。同时需要对问题进行分类、筛选，判断是属于哪一个模块、哪一个场景。

2. 制定测试计划：在确定问题后，制定相关测试计划，包括冒烟测试、功能测试、兼容性测试、显隐性测试、安全性测试，确保涉及到的功能通过测试使之达到可使用状态。

3. 重现问题：根据用户反馈提供的信息与测试计划，需要对功能进行测试，并模拟不同的使用场景，测试中需要全局考虑不同设备、不同浏览器等多个方面，以找出问题的根本原因。

4. 技术排查：如果问题不被归因到前面的测试环节中，则进行进一步的技术排查，例如进行代码分析或者调查程序日志，以确定问题所在模块、原因和解决方案。

5. 处理问题：在排查了问题原因后，进行二次确认、修复和测试，确保问题已经完全解决。同时，为了避免类似问题的再次发生，在根本原因确定后，需要对相应的测试流程进行相应的改进和优化，以提高测试覆盖面和测试效率。

综上所述，对于用户反映用不了的功能问题，测试人员应该针对不同环节，采取不同策略的排查方式，从测试计划的制定、测试环境的搭建、测试用例的设计到问题的排查定位，最终确定问题源，快速有效地解决问题并优化测试流程，以提高软件质量和用户的使用体验。

> Q：压测的时候，QPS一直上不去，你会怎么排查？
在压测中，QPS（每秒钟请求处理次数）上不去，这通常是系统性能瓶颈导致的，以下是一些排查方案：

1. 分析性能数据：在进行压力测试时，需要收集性能数据，如请求延迟、吞吐量、错误率等数据，根据这些指标分析系统性能表现，查看发生瓶颈的具体原因并优化测试参数。

2. 增加并发数量：系统响应的速度与请求的并发量相关，需要增加并发请求数量，以增大对系统的压力，达到提高 QPS 的目的。但是过高的并发量会导致系统瘫痪，需要根据系统限制做好平衡。

3. 增加硬件性能：可通过增加服务器的硬件性能，如 CPU、内存、存储等改善系统处理能力，提高 QPS 并缓解性能瓶颈。

4. 符合规范的代码：代码关键模块优化，诸如数据库连接池、nginx等中间件的配置和优化，能够大幅度改善系统性能。

5. 优化数据库操作：优化 SQL查询语句、表结构、索引、缓存机制等数据库一系列操作，从数据库上提升整个系统的性能。

6. 减少系统资源占用：优化运行环境，例如减少无用的服务、进程等可以减少系统对资源的占用，提升系统性能。

7. 其他优化措施：可以通过多种技术手段进行系统优化，例如采用缓存技术、异步消息机制、CDN 等，以减少请求的响应时间，从而提高系统 QPS。

综上所述，当 QPS 上不去时，需要从多个方面进行分析、测试和优化，包括性能数据分析、并发数量、硬件性能、代码优化、数据库操作优化、资源占用优化、其他优化措施等方面的排查，从而找到问题的根源，针对性地进行优化和调整，以满足系统高并发的需求。
> Q：APP提示无法连接网络，你会如何排查？
当 APP 提示无法连接网络时，可能是因为当前设备无法连接到互联网，也可能是因为应用自身网络模块出现异常。以下是一些排查方案：

1. 检查网络设置: 检查设备是否连接了 Wi-Fi 或者移动网络，并尝试打开浏览器确认网络是否正常，例如访问一个网站或者搜索引擎，确认网络是否正常。

2. 尝试重连：如果用户的网络连接不稳定，APP也会提示无法连接网络，并可能分别尝试重连。测试人员可以模拟网络异常情况，确认时 APP 是否会尝试重新连接网络，以确定 APP 网络模块是否存在相关问题。

3. 检查 APP 版本信息：检查 APP 当前的版本信息和最新可用的更新来确定是否存在与网络连接有关的问题，例如 APP 旧版本已知的网络问题，可通过更新来解决。

4. 查看应用日志：使用日志工具查看应用日志，如crash.log或syslog是否存在网络连接问题的相关信息，例如连接被拒绝或连接超时等，以便更好地确定问题出现的时间和原因。

5. 测试其他网络应用：如果其他应用程序可以正常访问互联网，例如浏览器，就说明该设备的网络设置正常，可以排除网络问题，需要对 APP 自身的网络模块进行进一步的排查和分析，并通过相关的测试方法进行修复。

6. 排查网络模块：对应用的网络模块进行测试，根据测试结果对网络模块进行相关优化，包括网络连接是否被正确封装、连接池管理是否合理、缓存机制是否有效、超时检测是否及时等。

综上所述，对于 APP 无法连接网络的问题排查，需要从网络设置、版本信息、应用日志、其他网络应用以及 APP 本身的网络模块等多个方面进行排查，寻找问题来源，然后针对性的进行处理和优化，以确保 APP 网络模块的稳定性和用户体验。
> Q：怎么判断一个BUG到底是前端的BUG还是后端的BUG？
在软件开发中，前端和后端在应用系统的开发和维护中，肩负着不同的任务并且存在交互和影响。判断一个 BUG 是前端的 BUG 还是后端的 BUG，需要从以下几个方面考虑：

1. 定义清晰的前后端边界：明确各模块的职责，并判断该 BUG 出现在哪个模块中，明确前后端职责并且深入了解各个模块之间的数据流，有助于判断 BUG 是出现在哪个模块中。

2. 环境预期表现：在开发前阶段，团队应该确定前后端条件下功能的预期表现。如果 BUG 不符合预期表现，那么该问题很可能出现在不符合预期表现的那一侧。例如，后端问题通常可以通过在命令行更改或使用工具在数据库中修复数据，而前端问题则通常需要刷新或清除缓存进行修复，可以通过区分环境表象来确定问题出现在哪个侧。

3. 重新现证据收集：资料的重现将有助于判断到底 Bug 属于前端还是后端问题。界面载入、页面重新生成、数据库写入和查询都可以是重新现问题的过程。重新说明判断问题并确定是否是前端或后端问题的一种好方法。

4. 测试技术栈：通过确定寻找 BUG 的方法、测试工具和测试组件，团队可以更轻松地锁定问题。后端测试通常涉及 API 或命令行接口等工具，并使用一些像 "Postman" 上的其他访问 API 的工具。前端测试的工具则通常涉及其他类型的方式，例如测试库（如Jasmine、Mocha 等等）来完成功能测试，并使用 Chrome 的开发工具或其他浏览器开发和测试插件来进行 UI 测试。

综上所述，通过清晰的前后端职责边界的区分、确定环境预期表现、重新现场证据收集以及测试技术栈的选择，有助于有效地判断该 BUG 是前端的 BUG 还是后端的 BUG。当然在实际测试中，也需要前后端进行配合并彼此协作，解决 BUG。

#### 实战案例
> Q：设计抖音直播功能测试用例
> 抖音直播功能是一项非常受欢迎的功能，下面给出一些可能用到的测试用例 :

1. 直播场景功能测试用例：

- 开启直播房间，进行直播演示
- 关闭直播房间并退出直播
- 游客、粉丝、用户互动功能测试
- 游客访问直播间延迟测试
- 弹幕频繁发布带宽测试
- 直播切换分辨率测试
- 直播场景美颜、滤镜测试

2. 直播流功能测试用例:

- 推流成功 / 失败的测试
- 推流中断后恢复推流的测试
- 流媒体服务器的测试
- 流数据解压测试
- 流数据格式测试：FLV、RTMP等
- 推流带宽测试

3. 礼物与商品测试：

- 观众赠送礼物，主播展示礼物的测试
- 缺货礼物展示的测试
- 主播显示批量赠送礼物的测试
- 虚拟商品直播购买的测试
- 实物商品列表及购买链接的测试

4. 异常情况测试：

- 在直播过程中应用崩溃的测试
- 网络环境差的条件下直播流的质量测试
- 视频畸变严重的测试
- 正在执行操作期间遭遇异常的测试
- 上百个用户进入直播后的功能测试

5. 安全测试：

- 预防钓鱼链接、诈骗链接的测试
- 防火墙测试
- 防 DDoS 攻击的测试
- 数据加密和安全传输协议的测试

6. 其他测试：

- 系统兼容性测试
- 数据一致性测试
- 服务器容量测试
- 频带测试
- 计算机资源和带宽测试

总而言之，测试过程中不能忽视任何细节，并在测试过程和测试用例部分使用自动化测试工具和相应技术，以验证抖音直播功能每一个模块的质量，从而提高应用程序的整体质量。
>
> Q：抖音视频的安全性测试，测试点有哪些？
> 抖音视频作为一款全球范围内广泛使用的移动应用，需要确保用户的隐私和安全，以下是抖音视频的安全测试点：

1. 用户隐私保护：对于用户的隐私数据进行测试，包括应用发布的相关政策准则，隐私协议的测试等，确保不会因应用程序的设计或漏洞而泄漏用户的隐私内容。

2. 数据传输安全：测试数据在本地和云端之间传输的安全性，以确保抖音的影片上传和下传通道没有泄露数据或者存在数据安全漏洞。

3. 访问权限控制：检查应用程序安全配置和作用权限，以防止不必要的信息泄露和安全漏洞。

4. 功能性安全：对应用程序中上传和分享视频、点赞、评论和追踪等核心功能进行测试，确认不存在漏洞和应用的功能能够正常使用。

5. 设备信息安全：应用程序设计应用保存的设备信息和通讯簿数据等，进行测试，以确保没有隐私漏洞，以及是否存储有安全漏洞。

6. 数字版权和内容审查安全：抖音应确保关于内容，包括音乐，图像和文本等的版权真实性和安全性，对于盗版内容应具备向版权持有人提交报告并进行处理的功能。

7. 滤镜技术测试：视频作为用户创作类的产品，对于包括滤镜，虚拟化等在内的技术进行相应的测试，确保应用在使用这些技术时没有隐私漏洞或安全缺陷。

综上所述，通过以上安全测试点的检查，可以确保抖音视频的整体安全性，用户隐私保护的重要性，结合高安全性的测试方案，可以让抖音视频更好地保护用户的隐私和安全。
>
> Q：搜索功能怎么测试？
搜索功能是任何应用程序一项重要的功能之一，用户搜索能够很快地帮助他们轻松地找到他们需要的内容，以下是针对搜索功能的测试用例：

1. 界面测试：

- 搜索框的位置、大小和样式是否符合设计规范。
- 搜索指令和搜索结果中的字体和大小是否易于读取和分辨。
- 搜索框中的提示文本和提示信息是否清晰、完整。

2. 过滤器和标签测试：

- 确认是否存在用于过滤搜索结果的选项，例如筛选、分类别或价格范围等。
- 测试标签和关键字的准确性，如果标签或关键字不当，应用程序是否仍能够返回相关结果。

3. 搜索功能测试：

- 搜索时是否支持输入匹配以及自动完成功能。
- 通过搜索功能查看所返回结果的完整性、准确性和一致性。
- 超时时间测试：在搜索大量数据集之后，应用程序是否会出现瓶颈和耗时现象。

4. 搜索结果分类和排序测试：

- 搜索功能返回的结果条目是否按照正确的排序方式排序，并且是否与其他平台结果排序方式一致。
- 在多个结果中查找并选择一个准确的结果的实验。
- 过滤和分类结果是否简单易用且支持正并反向排列。
- 按照不同抽空方式分类对结果进行一些操作，如给出点赞或收藏，确保系统仍能够准确展示。

5. 兼容性测试：

- 测试搜索功能在不同的浏览器、平台、系统和设备上的兼容性。
- 确定代码结构和数据一致性，确保在不同平台之间搜索功能使用稳定，并且没有使用任何应用程序功能所导致的问题。

综上所述，测试搜索功能需要关注界面，过滤器和标签，搜索功能本身、排序方式以及兼容性等多个方面，如果开发团队能够在早期进行搜索功能测试，将有助于确保应用程序的整体质量和用户体验。

### 四、语言基础

#### C++
<details>
<summary>Q：指针和引用的区别是什么？</summary>
C++中的指针和引用都是用来处理内存地址的，但它们有以下几个区别：

定义方式不同：指针是一个变量，它存储了一个内存地址，可以通过“*”操作符来访问该地址上的值；引用是一个别名，它引用了一个已经存在的变量，可以直接访问该变量的值。

空指针和空引用不同：指针可以被赋值为空指针，即指向空地址；引用必须在定义时初始化，不能引用空值。

操作方式不同：指针可以被重新赋值，可以进行指针运算，可以指向不同类型的变量；引用一旦被初始化，就不能再引用其他变量，也不能进行引用运算。

传递方式不同：指针可以作为函数参数传递，可以通过指针修改函数外部的变量；引用也可以作为函数参数传递，可以通过引用修改函数外部的变量，但是引用更加简洁和安全。

总之，指针和引用都是用来处理内存地址的，但它们的定义方式、空值处理、操作方式和传递方式等方面有所不同。在使用时需要根据具体情况选择合适的方式，以确保程序的正确性和可靠性。
</details>

#### Golang
> Q: slice的底层实现
Golang中的 Slice 是一个轻量级的数据结构，与传统的数组相比，它具有更强的灵活性和可扩展性。Slice 的底层实现是基于数组的连续存储空间以及 Slice 结构体中的三个指针构成的。

Slice 底层实现主要包括以下三部分：

1. Slice 结构体

Slice 结构体包含 3 个字段，它们分别是指向数组存储空间的指针、表示 Slice 长度的整型数值、表示 Slice 容量的整型数值。可以使用类似于 map、struct 等方式来定义一个 slice ，例如：

```
var s []int
```

2. 数组存储空间

Slice 底层的数据结构是一个连续的数组存储空间，当 Slice 的容量不足时，数组会自动扩容。数组扩容的规则如下：

- 如果新长度为当前容量的 2 倍及以下，则新容量为当前容量的 2 倍。
- 如果新长度为当前容量的 2 倍以上，则新容量为新长度，也就是将 Slice 容量扩大到与新长度相同。

由于数组是固定大小的存储空间，数组容量一旦确定就无法更改。因此，在使用 Slice 时，当 Slice 容量大于数组长度时，Go 会根据上述规则，重新分配存储空间并执行一次数据搬迁。

3. 三个指针

Slice 结构体中的 3 个字段分别对应数组存储空间的起始地址、Slice 的长度以及 Slice 的容量。其中，数组存储空间的起始地址是固定的，而 Slice 的长度和容量是不断变化的。

- 第一个指针是对数组存储空间的引用。
- 第二个指针是 Slice 的长度。
- 第三个指针是 Slice 的容量。

假设 Slice 为：s := []int{1, 2, 3, 4, 5}，那么 s[1:3] 就是一个 Slice，并且它的底层实现采用以下的方式：

```
arr := [5]int{1, 2, 3, 4, 5}
s := arr[1:3]
```

在这个实现中，s 对数组 arr 的引用是一个从下标 1 到下标 2 的连续元素片段。Slice 的底层实现是一个指向数组 arr 的指针、长度为 2，容量为 4 的 Slice 结构体。

总而言之，Slice 的底层实现是一种动态的、基于数组的存储结构，它具有相对较高的灵活性和可扩展性。了解 Slice 的底层实现有助于更好地理解 Golang 中 Slice 的使用和原理，从而写出高效、稳定的 Golang 代码。
> Q: map的底层实现
Golang 中的 Map 是一种无序的、键值对形式的集合类型，底层实现采用哈希表（Hash Table）数据结构。下面是 Golang Map 底层实现的详细介绍：

1. 内部结构

Golang 中 Map 的内部结构是一个哈希表，每个键值对都被存储在这个哈希表的一个桶（bucket）中。

哈希表内部的桶（bucket）是一个链表结构，使用链表可以解决哈希冲突的问题。当插入一个新的元素时，会根据键的哈希值计算出存储位置，然后将该键值对插入到这个桶的链表中。

2. Key 的哈希值

Golang 中 Map 的 Key 是任意类型的值，当使用一个 Key 值时，Go 会计算该值的哈希值，以确定存储在哈希表中的位置。

在 Golang 的哈希表中，每个键值对都被存储在一个桶（bucket）中。可以把桶看成一个集合，这个集合中存储了哈希表中所有具有相同哈希值的键值对，因此，在桶中查找一个键的效率必须足够高。

3. 冲突处理

哈希函数计算得到的哈希值可能会和其他 Key 的哈希值相同，这被称为“哈希冲突”。在哈希表中，每个桶（bucket）不仅可以存储一个键值对，还可以存储一个链表，因此，如果发生哈希冲突，可以在桶的链表中添加一个新的键值对。

4. 扩容和收缩

Map 的容量是动态的，并且是根据存储元素的个数动态调整的，当 Map 存储的元素个数超过了当前容量的 70% 时，系统就会进行容量扩容。容量扩增后会分配一个更大的桶数组，然后将所有键值对重新哈希映射到新的桶中，以减少桶的冲突，扩容所需时间的复杂度为 O(N)。

当 Map 存储的元素个数低于当前容量的一半时，系统就自动收缩容量，使容量变为元素个数的两倍。收缩所需的时间复杂度和扩容一样为 O(N)。

综上所述，Map 在 Golang 中是一种重要的数据结构，使用哈希表作为底层存储结构，可以快速地插入和查找元素。了解 Map 的底层实现有助于编写高效、稳定的 Golang 代码。

### 五、数据结构与算法

#### 复杂度

> Q：时间复杂度是什么？
算法的时间复杂度是指算法所耗费的时间和数据规模之间的关系，通常表示为一个函数。

一般来说，算法的时间复杂度越高，程序的执行时间就会相应增加。时间复杂度是衡量算法好与坏的一项重要指标之一，正确的时间复杂度分析可以帮助我们选用最优的算法。

常见的时间复杂度从小到大排列为：O(1)、O(log n)、O(n)、O(n log n)、O(n²)、O(n³)、O(2ⁿ)、O(n!)。

下面介绍一些常见的时间复杂度及其对应的例子：

- O(1) 常数阶：指得是在数组中查找某个元素或在哈希表中查找某个元素等这些操作， 不会随着数据规模增长而增加时间复杂度的算法。例如：对于一个整数矩阵的求和，数组中随机的取一个元素等。
- O(log n) 对数阶：指得是数据规模 n 增大时， 时间复杂度增长非常缓慢， 以 2 为底的对数。例如：二分查找，查找数据的时间复杂度的增长是慢慢变小的。
- O(n) 线性阶：指得是数据规模复杂度为 O(n) 的算法一般表现为 for 循环。例如：线性查找、冒泡排序等，随着数据规模的增大，算法的执行时间也会成线性增长。
- O(n log n) 线性对数阶：指得是某些分治算法，例如快速排序，时间复杂度通过一些手段优化后，得到了为 O(n log n) 的时间复杂度。
- O(n²) 平方阶：指得是数据规模 n 增大时， 时间复杂度增长非常快， 主要表现为两层嵌套的循环或递归。例如：选择排序、插入排序、快速排序（在特定情况下）等。
- O(n³) 立方阶：指得是通过三层循环实现的尝试和矩阵乘法。
- O(2ⁿ) 指数阶：特别的时间复杂度， 该时间复杂度的算法适用数据规模非常小的时候，过大的数据规模会使程序执行时间变得难以接受。例如：数据压缩算法中的霍夫曼编码、图形中搜所有路径的穷举搜索等。
- O(n!) 阶乘阶：指得是极其低效的算法，它的执行时间会随着数据规模的增大呈爆炸性增长。例如：基于全排列的 TSP（旅行商问题）等。

总而言之，时间复杂度是衡量算法好与坏的一项重要指标之一，正确的时间复杂度分析可以帮助我们选用最优的算法进行程序开发。

#### 排序
> Q：快排的原理
快速排序（Quick Sort）是一种常用的排序算法，也是一种基于交换比较的排序算法。它的基本思想是通过一趟排序将待排记录分割成两部分，分别比某个值大或者小，然后继续对这两部分进行排序直到整个序列有序。

快速排序的原理可以概括为以下几个步骤：

1. 选择基准值

首先从待排记录中选择一个基准值，一般是将序列中的第一个元素作为基准值。

2. 划分操作

通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的键值都比基准值小，另一部分记录的键值都比基准值大。这个过程叫做划分操作（Partition）。

划分操作通过两个指针 i 和 j 来实现。指针 i 指向待排记录的首位元素，指针 j 指向待排记录的末位元素。在最开始时，i 指向基准值，j 指向最后一个元素。

随着排序的进行，依次逐个比较 i 和 j 指针所指向的元素与基准值的大小关系，分情况对待：

- 若待排记录中 j 指向的元素大于等于基准值，则未找到小于基准值的元素，j 前移。
- 若待排记录中 i 指向的元素小于等于基准值，则未找到大于基准值的元素，i 后移。
- 若待排记录中 j 指向的元素小于基准值，且 i 指向的元素大于基准值，则交换 i 和 j 指向的元素。交换之后，i 后移、j 前移，直到 i 和 j 相遇为止。

该过程在最开始时 i 和 j 分别对应待排记录的首尾元素，经过若干轮比较后，i 和 j 会相遇，交换 i 指向的元素和基准值，则基准值左边的所有记录键值都小于等于基准值，右边的所有记录键值都大于等于基准值。

3. 递归操作

接着对基准值左右两边的待排记录分别进行递归操作，直到待排记录长度为 1 或 0 时停止递归，此时完成排序。

快速排序算法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。快速排序是一种非常常用的排序算法，也是一种性能非常好的排序算法，被广泛应用于各种编程语言中。


### 六、框架

#### 开发框架

##### Django

> Q：简单介绍一下Django的目录结构
>
> Q：了解什么是MVC么？为什么说 Django 是MTV模型？
>
> Q：一个网络请求在Django中的实现过程
>
> Q：uwsgi是什么？用uwsgi和用Django的原生启动方式，有什么区别？
>
> Q：了解 ORM 么？简单介绍一下Django的ORM映射
>
> Q：Django的 CBV 和 FBV 的区别？实际项目中你会使用哪种方式？为什么？
>
> Q：怎么把 Django 的 module 同步到数据库中？同步过程中会遇到什么坑么？

#### 测试框架

##### selenium

> Q：selenium框架的运行原理
Selenium 是一个自动化浏览器测试框架，它可以模拟用户操作浏览器并获取页面中的元素，进行验证、截屏、模拟事件触发、表单填写等操作。

Selenium 的运行原理可以概括为以下几个步骤：

1. 驱动浏览器
Selenium 使用驱动程序（如 ChromeDriver、FirefoxDriver 等）来启动浏览器，驱动程序是用来连接 Selenium 和浏览器的关键组件。使用 WebDriver 的 API，Selenium 可以对浏览器进行各种控制操作。

2. 获取网页源代码
Selenium 可以获取指定网址的源代码，以便进行后续的操作。首先，Selenium 向指定网址发送 HTTP 请求，然后从响应中获取网页源代码。

3. 查找元素
Selenium 通过浏览器的 DOM 树结构来查找网页中需要操作的元素。Selenium 支持各种定位元素的方法，如按类名、标签名、属性名和元素文本等，也支持 Xpath、CSS Selector 等高级定位方式。

4. 操作元素
一旦找到了需要操作的元素，Selenium 可以对其进行点击、发送文本、选择下拉列表、上传文件、设置属性等多种操作。对于需要处理 iframe 的界面，Selenium 还可以通过切换上下文的方式来定位及操作。

5. 等待界面加载
等待是 Selenium 测试中非常重要的一部分，可以保证测试在各种网络环境下都能够稳定运行。Selenium 提供了多种等待方式，如显式等待、隐式等待和 Fluent Wait 等，让测试可以等待界面加载完成后再执行操作。

6. 运行测试脚本
Selenium 是可以逐行运行测试脚本的，它可以按照编写顺序执行一系列的自动化测试用例，每次测试执行之后，还可以收集测试结果信息。

总体来说，Selenium 的运行原理就是驱动浏览器，使用 WebDriver API 操作浏览器，获取网页源代码，选择查找元素，进行操作，并等待界面加载。通过这些步骤，Selenium 可以模拟真实用户的操作并进行测试。
> Q：selenium定位元素的方法都有哪些？
Selenium 可以通过以下多种方法来定位元素，从而在浏览器页面中选择需要操作的元素：

1. By ID
通过元素的 ID 属性来定位，使用方法如下：
```python
driver.find_element(By.ID, 'element_id')
```

2. By Name
通过元素的 Name 属性来定位，使用方法如下：
```python
driver.find_element(By.NAME, 'element_name')
```

3. By Class Name
通过元素的 Class Name 属性来定位，使用方法如下：
```python
driver.find_element(By.CLASS_NAME, 'element_class_name')
```

4. By Tag Name
通过元素的标签名称来定位，使用方法如下：
```python
driver.find_element(By.TAG_NAME, 'element_tag_name')
```

5. By Link Text
通过元素的链接文本来定位超链接，使用方法如下：
```python
driver.find_element(By.LINK_TEXT, 'link_text')
```

6. By Partial Link Text
通过元素的链接部分文本来定位超链接，使用方法如下：
```python
driver.find_element(By.PARTIAL_LINK_TEXT, 'partial_link_text')
```

7. By Xpath
通过元素的 Xpath 表达式来定位，使用方法如下：
```python
driver.find_element(By.XPATH, 'xpath_expression')
```

8. By CSS Selector
通过元素的 CSS 选择器来定位，使用方法如下：
```python
driver.find_element(By.CSS_SELECTOR, 'css_selector_expression')
```

对于 find_element 方法，还有对应 find_elements 方法来查找多个元素，例如：
```python
driver.find_elements(By.CLASS_NAME, 'element_class_name')
```
以上方法是 Selenium 操作元素前的基础，需要了解并掌握，可以根据不同的场景选择最佳的定位元素的方法。

### 七、计算机基础

#### 操作系统

##### 进程/线程
> Q：何时cpu处理进程最慢？
CPU 处理进程最慢的情况通常是发生进程切换（Process Switching）的时候。具体来说，以下情况可能会导致 CPU 处理进程变慢：

1. 上下文切换

当操作系统需要将 CPU 资源从一个进程切换到另一个进程时，就会发生上下文切换，这个过程中 CPU 需要保存当前进程的上下文信息并恢复另一个进程的上下文信息，这会消耗一定的 CPU 时间，因此会导致 CPU 处理进程变慢。

2. 内存页的读取

如果一个进程需要访问的内存页不在物理内存中，CPU 需要将该页从硬盘上读取到物理内存中，这个过程也会导致 CPU 处理进程变慢。当然，这种情况也可以通过使用更高速的存储设备来缓解。

3. 频繁的系统调用

在进程执行过程中，如果需要频繁地进行系统调用，这样也会影响 CPU 处理进程的速度。因为系统调用需要切换至内核态（Kernel Mode），这会增加 CPU 的负担。

因此，为了尽可能避免这些因素对 CPU 处理进程的影响，可以采取一些措施，例如：优化进程、减少上下文切换、优化内存分配、避免频繁的系统调用等。
> Q：进程间通信的方式？ Q：线程间通信的方式？
>
在计算机操作系统中，进程（Process）和线程（Thread）通信是两个重要的问题。进程指的是正在运行的程序的实例化，而线程指的是进程中的单个执行单元。在多任务操作系统中，进程都是独立的，彼此之间无法直接访问，因此需要采用一些特殊的机制进行进程间通信（IPC，Inter-Process Communication），而线程间的通信相对比较简单，可以使用共享变量。以下是进程间通信和线程间通信的一些常用方式：

进程间通信方式：

1. 管道（Pipe）
管道是一种单向、线性的进程间通信方式，主要用于具有亲缘关系的父子进程间的通信。它会创建一个由内核控制的缓冲区，可以在生产者和消费者进程之间传递数据，比如操作系统中的 shell 程序和管道命令的执行程序之间的通信。

2. 信号（Signal）
信号是一种软件实体，用于通知进程发生了某个事件或错误，例如进程退出、空闲信号、非法指令等，它可以被其他进程或内核发送和接收。比如，当 Ctrl+C 被键入时，操作系统就会向正在运行的进程发送一个信号。

3. 消息队列（Message Queue）
消息队列是一种经典的进程间通信方式，主要用于进程之间传递数据的场景，消息队列可以被多个进程访问，按照先进先出的顺序存放多个消息。生产者进程可以将消息写入消息队列中，而消费者进程可以从消息队列中读取消息。

4. 共享内存（Shared Memory）
共享内存指的是两个或多个进程可以共享一个进程中的一块内存区域，任何一个进程都可以访问其他进程中定义的变量和指针。多个进程通过映射到它们的地址空间中来实现对此共享内存区域的访问。

5. 套接字（Socket）
套接字是一种可移植的进程间通信机制，可以在不同进程和计算机之间进行通讯，套接字最常用的情况之一是 Socket 程序，可以通过 TCP 或 UDP 协议等传输应用程序数据。

线程间通信方式：

1. 互斥量（Mutex）
互斥量（Mutex）是一种同步的机制，用于保证在任何时刻只有一个线程访问共享资源。通过上锁和解锁的方式来协调线程访问共享资源的顺序。

2. 信号量（Semaphore）
信号量是一种计数器，它用于表示资源的可用数量，多个线程可以通过信号量来进行同步。当信号量为 0 时，表示没有可用的资源，而当信号量为 1 时，表示有 1 个资源可用。

3. 条件变量（Condition Variable）
条件变量是一种线程间的同步机制，它可以在多个线程之间发送信号，以实现线程之间的通信。当一个线程需要等待一个事件发生时，它可以通过等待一个条件变量来进行等待，而其他线程排队在条件变量上等待事件发生后将信号发送到条件变量上。

4. 屏障（Barrier）
屏障是一种线程同步机制，它可以在一组线程到达某个位置之前使它们等待，一旦所有线程都到达了屏障，

##### 文件存储
> Q：视频在服务器的存储几种方式
> cos，cdn
> Q：CDN有什么用？
CDN（Content Delivery Network，内容分发网络）是一种通过在各个节点上缓存静态内容来提高 Web 访问速度和性能的技术，前端开发中的 CDN 主要用于以下几个方面：

1. 加速资源下载
使用 CDN 可以提高静态资源（如 JavaScript、CSS、图片等）的下载速度，这是因为 CDN 的分布式节点可以将资源缓存到离用户较近的地方，从而减少了跨域和带宽消耗问题。

2. 节省带宽消耗
通过使用 CDN，可以将主站的流量转移到 CDN 上，从而减轻主站的负担，节省带宽消耗和服务器维护成本。

3. 提高访问质量
使用 CDN 可以提供更好的稳定性和可用性，因为 CDN 在多个地点都部署有缓存服务器，即使某一个节点出现故障，也可以从其他节点获取数据，提高访问质量和可用性。

4. 安全性更高
通过 CDN 可以提高 Web 应用的安全性。例如，在 Web 应用程序中使用 Web 应用程序防火墙（WAF）可以在部署 CDN，通过对黑名单、白名单和恶意行为监控等多维度的检测方式，提供更加细致的安全防护，有效缓解 Web 应用程序面临的各种安全问题。

综上所述，前端开发中的 CDN 可以提高静态资源的下载速度和性能、节省带宽消耗、提高访问质量、提高安全性等多个方面的优势，因此应用广泛。常用的云平台商有阿里云，腾讯云等大型CDN厂商提供CDN服务。

##### 其他
> Q：谈谈什么是分布式？为什么要用分布式？
分布式（Distributed）指的是将一个计算任务分摊到多台计算机上进行，通过计算机间的协作完成任务。分布式计算是一种依靠网络互联的、以分治算法为设计思想的、多计算机协同工作的计算。

分布式系统是指分布于多个位置、由多个计算节点组成的系统，这些节点之间通过网络相互连接，并协同工作以完成特定的任务，在分布式系统中，各个节点是相对独立并且互相通讯。

在实际应用中，为了满足高性能、高可用性和高扩展性的需求，常常需要将应用系统设计成分布式系统，其中包括：

1. 提高可靠性和容错性
将应用部署在多台服务器上，若系统发生故障，可以通过其他节点接管服务，从而保证系统的可用性。

2. 提高系统性能
将任务分割为多个子任务，通过分布在不同节点上的计算机同时处理，从而缩短计算时间，提高系统性能。

3. 易于扩展
分布式系统可根据应用需求动态扩展节点数，以满足系统不断增长的需求。

4. 提高网络带宽利用率
将资源部署在不同节点上，可以充分利用网络带宽资源。

总之，分布式技术能够在适当的方面应对复杂且高负载的应用场景，并带来更好的容错性、性能、伸缩性和可靠性，在现代分布式系统中的应用非常普遍，例如云计算、大数据等领域。


#### 数据库

##### 非关系型数据库
> Q：什么时候适合用MongoDB？
MongoDB 是一种文档型（Document）数据库，适用于许多场景，包括以下几个方面：

1. 大数据量应用
MongoDB 具有良好的可扩展性和性能，支持水平扩展，适合于处理大量数据和高并发请求。

2. 高灵活性应用
MongoDB 使用基于文档（Document）的数据存储结构，提供高度灵活的数据模型，在数据的结构上具有非常高的灵活性，极大程度地改善了开发人员的工作效率和数据存储的可扩展性。

3. 高可用性和容错性应用
MongoDB 内置了高可用和容错机制，通过分布式、多节点部署架构，来保证 可用性、容错性，对于一些在线系统，互联网应用，金融交易，企业级服务器等关键业务，使用 MongoDB 可以保证数据安全性。

4. 非结构化、半结构化数据存储和处理应用
MongoDB 将数据存储为 JSON 格式的 BSON（一种二进制序列化形式），它支持非结构化数据存储和处理，并可以存储具有不同类型的文档，使得数据存储和处理非常方便。

5. 因为MongoDB支持的查询特性
MongoDB 支持复杂查询，支持多重条件表达，支持 JavaScript 执行，使得开发人员在进行查询时灵活性很高。

总之，MongoDB 是一种高度灵活、支持大数据处理、高可用性和具有可扩展性的文档数据库，特别适用于需要高度灵活和可扩展性、并需要处理非结构化、半结构化数据的应用程序，例如 Web 应用程序、实时数据集成、移动应用程序、日志分析、物联网应用程序等。
> Q：Redis 的数据是存储在内存当中的，假如断电之后就会造成数据丢失，那怎么对 Redis 进行数据固化？
Redis 的数据确实是存储在内存中的，所以如果 Redis 节点因为某些原因而崩溃或宕机，则可能会丢失一部分或全部数据。为了避免这种情况，需要对 Redis 进行数据固化，主要有以下两种方式：

1. RDB 持久化
RDB 持久化是将 Redis 数据库保存到磁盘上的一种方式。在 Redis 配置文件中，可以通过设置 save 或者 save 900 1 这类参数来控制 RDB 持久化的方式和频率。当设置的时间间隔到达后，Redis 会自动将此时的内存数据保存至磁盘中，生成一个 RDB 文件，以此来达到数据固化的目的。RDB 文件可以用于备份、数据迁移和恢复等场景。

2. AOF 持久化
AOF 持久化是以日志形式记录 Redis 操作的一种方式。在 Redis 配置文件中，可以通过设置 appendonly yes 并给出 AOF 文件的存储路径，来启用 AOF 持久化。当 Redis 中的数据发生更改时，Redis 会把命令以日志形式记录在 AOF 文件中，当 Redis 重启时，可以通过读取 AOF 文件中的命令历史记录来还原 Redis 中的数据状态。

这两种方式各有优缺点，RDB 持久化操作快、恢复速度快，但是可能会丢失一定的数据；而 AOF 持久化数据安全性更好，但是启用 AOF 持久化会增加系统的开销。

为了提高数据安全性，一般会同时启用 RDB 和 AOF 持久化，当 Redis 重启时，会首先读取 AOF 文件，再读取 RDB 文件，以此来保证数据的最大可靠性。同时，还可以通过 Redis Sentinel 或者 Redis Cluster 来实现数据备份和高可用性部署。
##### 关系型数据库

**数据库基本理论**
> Q：关系型数据库和非关系型数据库的区别？
关系型数据库和非关系型（NoSQL）数据库是两种不同类型的数据库，其主要区别如下：

1. 数据存储方式不同
关系型数据库采用表格（二维表）的方式来存储数据，表格将数据组织成多个关系型的行和列。而非关系型数据库则采用键值对、文档、列族等方式来存储数据，数据结构可以灵活定义。

2. 数据之间的关系不同
在关系型数据库中，数据之间的关系是直接通过外键或者联结等方式建立的，所以数据之间的关系比较明确和严格。而在非关系型数据库中，数据之间的关系通常是通过嵌套、引用、数组等方式实现的，并不是直接的联系，因此数据之间的关系比较模糊、灵活。

3. 数据量和查询方式的异同
关系型数据库一般适用于较小规模的数据，其查询方式是基于 SQL 语言的，支持复杂的关系查询。而非关系型数据库一般适用于大型、高性能数据环境，其查询方式则根据不同的 NoSQL 数据库而异，通常具有高可伸缩性、高并发性，但不一定支持复杂的关系查询。

4. 数据的一致性不同
关系型数据库通过 ACID（原子性、一致性、隔离性和持久性）事务保证数据的一致性，即在数据库事务执行成功后，数据一定保存成功。而非关系型数据库通常采用 BASE（基本可用、软状态、最终一致性）理论，它放宽了数据的一致性要求，强调系统的可用性和性能，追求更为灵活和高效的数据处理方式。

总之，关系型数据库和非关系型数据库具有不同的数据存储方式、数据之间的关系、数据量和查询方式、数据的一致性和可用性等方面的异同，开发人员应根据项目需求选择适合的数据库解决方案。
> Q：数据库的事务有什么用？什么时候应该使用事务，什么时候不该使用事务？
数据库的事务是指把操作集合作为单个工作单元来执行的机制，这些操作被视为原子性，要么全部成功执行，要么全部不执行，以此来保证数据库的完整性和一致性。它带来的好处包括：

1. 数据的完整性和一致性
事务可以把多个数据操作（例如增、删、改、查等）视为一个整体进行操作，这样可以在操作失败时将整个操作回滚，保证数据的一致性和完整性。

2. 并发控制
由于事务是原子性的，所有并发通过事务控制可以避免多个用户的并发更新数据产生的问题，有效地保证了数据的一致性。

3. 提高数据处理的效率
将多个数据操作合并为一个事务来处理，避免了频繁地进行数据库读写操作，提高数据处理的效率。

4. 可以进行复杂操作
事务支持嵌套、保存点、回滚等复杂操作，可以满足更多不同需求的应用场景。

在进行数据库开发中，应该根据具体的业务场景来考虑是否使用事务。

应该使用事务的情况包括：

1. 高并发的场景下，需要保证数据的一致性和完整性。

2. 数据库操作需要进行复杂的嵌套、保存点、回滚等情况。

3. 多个数据更新或操作需要被当做单个操作来执行时。

而在以下情况下，不应该使用事务：

1. 单个操作即可完成的场景，一条 SQL 语句可以独立完成整个任务，此时不需要使用事务。

2. 对于一些查询操作，由于查询的是只读数据，数据不可更改，没有更新或删除的情况，此时也不需要使用事务。

3. 时效性要求不高的场景，对数据的更改没有太高的时效性、重要性，且不会影响业务流程和其他数据时，可以不使用事务。

总之，在使用事务时，应根据具体业务场景来酌情考虑，用于保证数据的一致性与完整性。
> Q：主键适合用自定义ID还是自动ID？

主键适合使用自动ID。

自动ID是指数据库系统自动生成的唯一标识符，通常使用自增长的整数或UUID等方式生成。自动ID的优点是简单、高效、可靠，可以确保每个记录都有唯一的标识符，避免了手动分配ID时可能出现的重复和错误。

相比之下，自定义ID需要开发人员手动分配，需要考虑到唯一性、长度、可读性等问题，容易出现错误和冲突。另外，自定义ID还需要考虑到分布式系统的情况，需要保证在不同的节点上生成的ID不会重复。

因此，一般情况下，主键适合使用自动ID。当然，在某些特殊情况下，例如需要将主键暴露给用户或需要保证主键的可读性时，可以考虑使用自定义ID。但是，需要注意到自定义ID可能会带来一些额外的开发和维护成本，需要根据实际情况进行选择。
![img.png](img.png)

> Q：外键是什么？为什么大公司有时候不建议使用外键？
外键是关系型数据库中的一种约束，它用于在一个表中对另一个表中数据的引用，并确保相应的引用完整性。一个外键关系通常由两个表中的两个字段组成，其中一个是主表中用来唯一标识记录的字段，另一个是从表中指向主表的字段。引用外键可以通过创建外键约束来实现，该约束规定了引用代码完整性规则，以便当引用的行发生更改或删除时，不会破坏数据库中的引用完整性。

虽然引入外键可以给数据库中的数据完整性带来很大好处，但有时候大公司会不建议使用外键的原因在于：

1. 性能问题
当数据库中有大量的外键引用时，这些引用需要频繁地进行检查和维护，导致数据库的响应时间变慢，从而影响系统的性能。

2. 处理复杂性问题
如果数据库中表和表之间的关系比较复杂，使用外键来管理这些关系会变得非常困难，并且可能导致性能问题。

3. 数据库维护的复杂性问题
当数据库中包含很多外键关系时，这些关系会增加数据库的维护成本，需要更多的系统资源来维护、更新和修复。

因此，在某些情况下，一些大型公司只建议使用外键来辅助数据完整性，而不是仅仅依赖外键来维护数据完整性。为了确保数据被正确管理，在数据的设计和开发过程中，应该适当地使用外键，并在设计时充分考虑性能、复杂性和维护性等因素。
> Q：索引设置得越多越好吗？索引得优缺点是什么？
索引不是越多越好，因为索引的设置会对数据库的性能产生影响。数据库的索引是在数据库中存储一份数据的副本，虽然它大大提高了数据库查询的速度，但也带来了一些优缺点。

优点：

1. 提升查询效率
索引可以极大地提升查询速度，特别是在海量数据的情况下，在频繁查找的字段上设置索引，可以使查询时间大大缩短。

2. 唯一性约束
索引可以设置为唯一性约束，即一个包含该列的索引可以避免出现重复值，保证数据的唯一性。

3. 排序优化
索引可以很好的优化数据库的排序操作，特别是在ORDER BY语句中使用非常有效。

缺点：

1. 增加了存储开销
每个索引都需要存储相应的索引信息，因此会随着索引的增多而增加存储空间的开销。

2. 降低了更新操作的效率
对含有索引的表进行更新操作时，由于需要维护索引，因此会降低更新操作的效率。

3. 频繁查询字段不一定适合创建索引
如果查询数据的字段是非常频繁的，不创建索引反而会更快一些。

综上所述，虽然索引可以很好地提升查询效率，但是也需要在合适的字段上建立索引，过多或选择不合适的索引会导致相反的结果，使得查询效率反而降低，掌握好索引的使用场景以及索引的优缺点，才能实现最优的数据库设计和优化。
> Q：InnoDB是基于什么实现的？
InnoDB 是一个 MySQL 存储引擎，它是基于 MVCC（多版本并发控制）实现的。MVCC 是指数据库系统为了保证并发访问而设计的一种控制机制，它的实现过程中采用了多种技术手段，如多版本控制、锁、时间戳、快照等方式，以实现高并发下的数据管理。

具体来讲，InnoDB 在存储数据时，会对每个数据增加两个隐藏的列，即 “DB_TRX_ID” 和 “DB_ROLL_PTR”。其中，“DB_TRX_ID” 表示这条数据所属事务的 ID，而 “DB_ROLL_PTR” 则表示数据的回滚指针，在实现 MVCC 机制时，会依据这个指针进行数据回滚等操作。

在使用 InnoDB 存储引擎进行数据库操作时，它提供了一系列的行级锁、表级锁等锁机制，以及事务隔离级别等参数，帮助我们减少并发操作冲突，控制事务的正常执行，实现可靠性较高的数据管理。此外，在 InnoDB 内部，它还实现了一些重要的数据结构，如缓存池、多版本存储、页面大小设置、日志记录、崩溃恢复等，以保证数据的高效处理，提高稳定性和数据安全性。

总之，InnoDB 存储引擎是基于 MVCC 机制实现的，具有诸多优点，如支持高可靠性和高并发等，它是 MySQL 数据库中最常使用的存储引擎之一。
> Q：为什么会造成数据库死锁？怎么解决？
数据库死锁是指两个或多个事务占用了对方所需的资源不放弃，从而形成的一种无解的僵局，使得数据库操作无法继续执行。造成数据库死锁的原因主要有以下几个：

1. 竞争资源
当多个事务同时请求使用某些相同的资源，如同一数据块、同一表的行、同一连接的锁等，一个事务同时又阻塞了其他事务获取相同资源的请求，就可能导致死锁问题。

2. 多个事务执行顺序不一致
当多个事务在其执行顺序上出现差异时，可能会导致死锁问题。例如，当执行事务A、事务B时，事务A持有锁X并请求锁Y，而事务B持有锁Y并请求锁X时，就可能形成死锁。

针对如何解决死锁，则可采用以下措施：

1. 加锁顺序问题
尽量规避针对同一批资源锁由不同事务加锁顺序不一致的情况，可以通过程序中对锁进行排序或者加锁规划，缩小死锁范围。

2. 减少事务并发冲突机率
降低事务并发程度，例如优化业务、加强数据库主从复制配置、划定单个线程对锁的争夺等、加空闲线程等待时间。

3. 将死锁问题置于一旁
主要是依赖于MySQL的死锁检测器（Deadlock detector），当出现死锁的时候，检测器可以终止某些事务，或者回滚某些操作，使数据库重新进入正常操作状态，可以通过调整死锁检测器的相关参数来优化死锁检测检验的频率和影响范围。

4. 优化SQL语句中JOIN、SELECT等问题
消除极其复杂的查询操作，从而简化业务流程，优化SQL语句可以改进死锁产生的机会。

总之，在面对数据库死锁问题时，开发者需要具备较为扎实的数据库知识，以及对业务场景的深刻理解，才能有针对性地解决死锁问题，保证数据库的正常操作。
> Q：为什么要进行分表分库？
随着数据量不断增大，如果不进行分表分库，会给数据库查询和维护带来很大的困难。因此，在到达一定数据量的时候，进行分表分库就变得非常必要。主要有以下几个原因：

1. 提高查询速度
当数据量增大时，在单张表中查询数据的速度会降低，这时为了提高查询的速度，可以根据数据量分成多张表，从而分布式存储数据，提高数据库的查找和查询速度。

2. 数据分布均衡
分表可以将数据分布到多个物理服务器上，避免单台服务器出现存储容量耗尽或者性能瓶颈情况，提高数据库查询的稳定性和可用性。

3. 关联查询的优化
使用分表分库可以更加精细的设计数据结构，从而减少不必要的关联查询，增强数据库的优化效果。

4. 扩展性
在未来，随着数据的不断增长，分表分库可以为业务提供更多的数据扩展性，符合系统不断扩展的业务需求，可以满足高度并发、海量数据存储等应用场景。

总之，分表分库可以提高数据库的查询效率、可用性和性能，但是也会带来一些分布式系统的问题，如一致性、事务处理等等，因此，在进行分表分库时应该根据实际情况进行评估和设计，合理规划数据库的数据结构，从而更好地支持业务发展和应用部署。
> Q：分表分库有哪几种方式？举例说明
进行分表分库有多种方式，以下是几种常见的方式：

1. 垂直切分：是指按业务功能将表拆分为多张表，将不同的表存储在不同的库实例中。这种方式的优点在于可以将不同业务的数据隔离在不同的数据库环境中，也更加利于数据库性能的优化。例如，将用户表和订单表分别存储在不同的数据库中，从而使查询速度更快。

2. 水平切分：是指将同一个表中的数据按照一定规则分到不同的物理表中，例如根据主键哈希函数实现的分库或分表等方式。这种方式的好处是可以大大减轻单张表数据量过大的压力，同时提高查询效率和数据库的吞吐量。例如，可以按照用户 ID 将用户表水平切分为多张表，不同用户的数据存储在不同的表中。

3. 一主多从：是指将主数据库分为多台实例，并在每个实例上建立从属关系，实现读写分离。写操作在主库中完成，而读操作可以流向任何一个从库中进行查询，有效减轻了对主库的压力。例如，将读多写少的数据可以经由从库来读取，而写操作则由主库完成。

4. 分片：是指按照应用场景的特殊要求进行划分，将同一种数据分散或复制到多个节点，每一个节点上存放同一数据子集的不同部分，从而形成一个可以处理海量数据的分布式数据库系统。例如，根据用户的客户端IP地址将数据库水平分片，将同一IP段的用户请求路由至同一数据库，从而实现数据的快速访问和高效处理。

以上是几种分表分库的方式，每种方式都有其适用的业务场景和优缺点，需要根据实际情况进行选择和使用，以最大化地提高数据库的性能和稳定性。

**SQL**
> Q：删除数据的方式有哪些？说说 drop table和truncate table的区别？
在数据库中，删除数据有以下两种方式：

1. Drop Table：删除整张表及其相关对象（约束、索引等），同时释放表占用的存储空间。

2. Truncate Table：清空整张表的数据，而不是删除整张表及其相关对象，同时释放表占用的存储空间。

区别如下：

1. 删除操作的性能： Drop Table 操作与 Truncate Table 操作的差异最明显的表现在底层实现上，由于 Drop Table 要删除整个表及相关对象，需要执行复杂的 DDL 操作，所以执行的时间和资源消耗要比 Truncate Table 高。

2. 删除操作的效果：Drop Table 和 Truncate Table 的效果是不同的，Drop Table 不仅删除指定的表数据，同时还连同表对象、触发器、索引、约束等对象一起删除，而 Truncate Table 则只删除表数据，而不删除其他对象。

3. 取消删除操作的结果： Drop Table 和 Truncate Table 操作均不可恢复，但是，如果 Drop Table 操作后需要尽快恢复，可以通过 flashback 操作来实现，而 Truncate Table 没有相应的恢复机制。

需要注意的是，无论是 Drop Table 还是 Truncate Table 对象，都会造成数据的永久性删除，因此在执行这些删除操作之前应该进行必要的备份和数据恢复机制的准备工作，切勿将其用于生产环境中的重要数据表。


### 十、HR常问

> Q：最近看了什么书？学了什么？为什么学？有看什么技术书籍吗？
AIGC  大模型原理

> Q：为什么要离职？
追求更好地业务，产生更多的影响

# 对测试和测试开发的理解？
测试和测试开发是软件开发过程中的两个关键职责。它们都关注于确保软件应用程序按照要求正常、可靠且安全地运行。然而，测试（Tester）和测试开发（Test Developer）岗位之间存在一些明确的差异。

**测试（Tester）**：
测试人员主要负责测试软件应用程序以确保其质量、性能和正确性。测试人员通常会创建和执行详细的测试计划并验证软件功能是否符合预定义的需求。他们可能会执行以下任务：

1. 分析需求并设计详细的测试用例。
2. 进行手动或自动测试以验证软件功能和性能。
3. 执行功能测试、集成测试、系统测试、性能测试、安全测试等各种类型的测试。
4. 在软件生命周期中的不同阶段进行测试，如单元测试、Smoke 测试、回归测试。
5. 跟踪并报告软件缺陷，并与开发团队紧密合作以解决问题。
6. 编写测试报告，包括软件质量和性能方面的度量。

**测试开发（Test Developer）**：
测试开发人员将研发和测试技能结合起来，主要负责开发自动化测试工具和框架。这些工具可以大大提高测试速度和效率，使每次更改后都可以快速验证软件质量。测试开发人员通常执行以下任务：

1. 设计、开发和维护自动化测试框架和工具。
2. 编写自动化测试脚本以覆盖多种场景。
3. 集成自动化测试到 CI/CD（持续集成/持续部署）管道中。
4. 提高自动化测试覆盖率，以确保关键功能受到合适的测试保护。
5. 修改、更新和优化现有自动化测试脚本，以消除冗余和提高效率。
6. 跟踪自动化测试的效果，识别不能有效地自动化的部分并进行手动测试。

总之，测试人员关注软件产品的质量，验收各项功能的正常运行；而测试开发人员侧重于建立自动化测试系统，提高软件测试周期和质量的效率。这两个角色都对软件产品的质量和性能有着至关重要的影响。在实际开发过程中，需要充分理解和发挥这两个岗位的优势，以提高软件质量和用户满意度。
